/*
Distributed under both the W3C Test Suite License [1] and the W3C
3-clause BSD License [2]. To contribute to a W3C Test Suite, see the
policies and contribution forms [3].

[1] http://www.w3.org/Consortium/Legal/2008/04-testsuite-license
[2] http://www.w3.org/Consortium/Legal/2008/03-bsd-license
[3] http://www.w3.org/2004/10/27-testcases
*/

/*
 * This file automatically generates browser tests for WebIDL interfaces, using
 * the testharness.js framework.  To use, first include the following:
 *
 *   <script src=/resources/testharnessreport.js></script>
 *   <script src=/resources/testharness.js></script>
 *   <script src=/resources/WebIDLParser.js></script>
 *   <script src=/resources/idlharness.js></script>
 *
 * The entry point is a single constructor, IdlInterface.  To test an
 * interface, do something like
 *
 *   new IdlInterface('interface Foo { readonly attribute DOMString bar; };').test();
 *
 * This is equivalent to calling a whole bunch of test()s that check various
 * aspects of WebIDL conformance.  The constructor will throw if the IDL can't
 * be parsed, or doesn't parse to exactly one interface.  test() will throw if
 * the interface has [NoInterfaceObject].  In the future, more tests will
 * hopefully be autogenerated, and more methods will be added to allow testing
 * other things about the interface (like whether a particular object
 * implements it correctly).
 */
"use strict";
(function(){

//This class is for the sake of has_extended_attribute, defined below.
function IdlInterfaceMember(obj)
{
    for (var k in obj)
    {
        if (k == "extAttrs")
        {
            this.extAttrs = obj.extAttrs ? obj.extAttrs : [];
        }
        else
        {
            this[k] = obj[k];
        }
    }
}

function IdlInterface(idl)
{
    var idl = WebIDLParser.parse(idl);
    if (idl.length != 1 || idl[0].type != "interface")
    {
        throw "Not supported";
    }
    idl = idl[0];
    this.name = idl.name;
    this.extAttrs = idl.extAttrs ? idl.extAttrs : [];
    this.members = idl.members ? idl.members.map(function(m){return new IdlInterfaceMember(m)}) : [];
    this.inheritance = idl.inheritance ? idl.inheritance : [];
}

window.IdlInterface = IdlInterface;

IdlInterfaceMember.prototype.has_extended_attribute =
IdlInterface.prototype.has_extended_attribute = function(name)
{
    return this.extAttrs.some(function(o) {
        return o.name == "name";
    });
};

IdlInterface.prototype.test = function()
{
    if (this.has_extended_attribute("NoInterfaceObject"))
    {
        throw "NoInterfaceObject interfaces can't be meaningfully tested";
    }

    var interface_obj = this;

    test(function() {
        //"For every interface that is not declared with the
        //[NoInterfaceObject] extended attribute, a corresponding property
        //must exist on the interface’s relevant namespace object. The name
        //of the property is the identifier of the interface, and its value
        //is an object called the interface object. The property has the
        //attributes { [[Writable]]: true, [[Enumerable]]: false,
        //[[Configurable]]: true }."
        //TODO: Should we test here that the property is actually writable
        //etc., or trust getOwnPropertyDescriptor?
        assert_own_property(window, interface_obj.name,
                            "window does not have own property " + format_value(interface_obj.name));
        assert_true(Object.getOwnPropertyDescriptor(window, interface_obj.name).writable,
                    "window's property " + format_value(interface_obj.name) + " is not writable");
        assert_false(Object.getOwnPropertyDescriptor(window, interface_obj.name).enumerable,
                     "window's property " + format_value(interface_obj.name) + " is enumerable");
        assert_true(Object.getOwnPropertyDescriptor(window, interface_obj.name).configurable,
                    "window's property " + format_value(interface_obj.name) + " is not configurable");

        //"Interface objects are always function objects."
        //"If an object is defined to be a function object, then it has
        //characteristics as follows:"
        //"Its [[Prototype]] internal property is the Function prototype
        //object."
        //FIXME: The spec is wrong, has to be Object.prototype and not
        //Function.prototype.  I test for how browsers actually behave,
        //assuming the bug will be fixed:
        //http://www.w3.org/Bugs/Public/show_bug.cgi?id=14813
        assert_true(Object.prototype.isPrototypeOf(window[interface_obj.name]),
                    "prototype of window's property " + format_value(interface_obj.name) + " is not Object.prototype");
        //"Its [[Get]] internal property is set as described in ECMA-262
        //section 15.3.5.4."
        //"Its [[Construct]] internal property is set as described in ECMA-262
        //section 13.2.2."
        //TODO: I'm not sure how to test these.
        //"Its [[HasInstance]] internal property is set as described in
        //ECMA-262 section 15.3.5.3, unless otherwise specified."
        //This needs to be tested in some other assertion that takes an object
        //that's supposed to be an instance of the interface.

        //"The [[Class]] property of the interface object must be the
        //identifier of the interface."
        assert_equals(String(window[interface_obj.name]), "[object " + interface_obj.name + "]",
                      "String(" + interface_obj.name + ")");
    }, this.name + " interface: existence and properties of interface object");

    test(function() {
        assert_own_property(window, interface_obj.name,
                            "window does not have own property " + format_value(interface_obj.name));

        //"The interface object must also have a property named “prototype”
        //with attributes { [[Writable]]: false, [[Enumerable]]: false,
        //[[Configurable]]: false } whose value is an object called the
        //interface prototype object. This object has properties that
        //correspond to the attributes and operations defined on the interface,
        //and is described in more detail in section 4.5.3 below."
        assert_own_property(window[interface_obj.name], "prototype",
                            'interface "' + interface_obj.name + '" does not have own property "prototype"');
        var desc = Object.getOwnPropertyDescriptor(window[interface_obj.name], "prototype");
        assert_false(desc.writable, interface_obj.name + ".prototype is writable");
        assert_false(desc.enumerable, interface_obj.name + ".prototype is enumerable");
        assert_false(desc.configurable, interface_obj.name + ".prototype is configurable");

        //"The interface prototype object for a given interface A must have
        //an internal [[Prototype]] property whose value is as follows:
        //"If A is not declared to inherit from another interface, then the
        //value of the internal [[Prototype]] property of A is the Array
        //prototype object ([ECMA-262], section 15.4.4) if the interface
        //was declared with ArrayClass, or the Object prototype object
        //otherwise ([ECMA-262], section 15.2.4).
        //"Otherwise, A does inherit from another interface. The value of
        //the internal [[Prototype]] property of A is the interface
        //prototype object for the inherited interface."
        var inherit_interface;
        if (interface_obj.inheritance.length)
        {
            inherit_interface = interface_obj.inheritance[0];
        }
        else if (interface_obj.has_extended_attribute("ArrayClass"))
        {
            inherit_interface = "Array";
        }
        else
        {
            inherit_interface = "Object";
        }
        assert_own_property(window, inherit_interface,
                            'should inherit from ' + inherit_interface + ', but window has no such property');
        assert_own_property(window[inherit_interface], "prototype",
                            'should inherit from ' + inherit_interface + ', but that object has no "prototype" property');
        assert_true(window[inherit_interface].prototype.isPrototypeOf(window[interface_obj.name].prototype),
                    'prototype of ' + interface_obj.name + '.prototype is not ' + inherit_interface + '.prototype');
    }, this.name + " interface: existence and properties of interface prototype object");

    test(function() {
        assert_own_property(window, interface_obj.name,
                            "window does not have own property " + format_value(interface_obj.name));
        assert_own_property(window[interface_obj.name], "prototype",
                            'interface "' + interface_obj.name + '" does not have own property "prototype"');

        //"If the [NoInterfaceObject] extended attribute was not specified on
        //the interface, then the interface prototype object must also have a
        //property named “constructor” with attributes { [[Writable]]: true,
        //[[Enumerable]]: false, [[Configurable]]: true } whose value is a
        //reference to the interface object for the interface."
        assert_own_property(window[interface_obj.name].prototype, "constructor",
                            interface_obj.name + '.prototype does not have own property "constructor"');
        assert_true(Object.getOwnPropertyDescriptor(window[interface_obj.name].prototype, "constructor").writable,
                    interface_obj.name + ".prototype.constructor is not writable");
        assert_false(Object.getOwnPropertyDescriptor(window[interface_obj.name].prototype, "constructor").enumerable,
                     interface_obj.name + ".prototype.constructor is enumerable");
        assert_true(Object.getOwnPropertyDescriptor(window[interface_obj.name].prototype, "constructor").configurable,
                    interface_obj.name + ".prototype.constructor in not configurable");
        assert_equals(window[interface_obj.name].prototype.constructor, window[interface_obj.name],
                      interface_obj.name + '.prototype.constructor is not the same object as ' + interface_obj.name);
    }, this.name + " interface: existence and properties of interface prototype's object constructor member");

    for (var i = 0; i < this.members.length; i++)
    {
        var member = this.members[i];
        if (member.type == "const")
        {
            test(function() {
                assert_own_property(window, interface_obj.name,
                                    "window does not have own property " + format_value(interface_obj.name));

                //"For each constant defined on an interface A, there must
                //be a corresponding property on the interface object, if
                //it exists."
                assert_own_property(window[interface_obj.name], member.name);
                //"The value of the property is that which is obtained by
                //converting the constant’s IDL value to an ECMAScript
                //value."
                assert_equals(window[interface_obj.name][member.name], eval(member.value),
                              "property has wrong value");
                //"The property has attributes { [[Writable]]: false,
                //[[Enumerable]]: true, [[Configurable]]: false }."
                var desc = Object.getOwnPropertyDescriptor(window[interface_obj.name], member.name);
                assert_true(desc.writable, "property is not writable");
                assert_true(desc.enumerable, "property is not enumerable");
                assert_true(desc.configurable, "property is not configurable");
            }, this.name + " interface: constant " + member.name + " on interface object");
            //"In addition, a property with the same characteristics must
            //exist on the interface prototype object."
            test(function() {
                assert_own_property(window, interface_obj.name,
                                    "window does not have own property " + format_value(interface_obj.name));
                assert_own_property(window[interface_obj.name], "prototype",
                                    'interface "' + interface_obj.name + '" does not have own property "prototype"');

                assert_own_property(window[interface_obj.name].prototype, member.name);
                assert_equals(window[interface_obj.name].prototype[member.name], eval(member.value),
                              "property has wrong value");
                var desc = Object.getOwnPropertyDescriptor(window[interface_obj.name], member.name);
                assert_true(desc.writable, "property is not writable");
                assert_true(desc.enumerable, "property is not enumerable");
                assert_true(desc.configurable, "property is not configurable");
            }, this.name + " interface: constant " + member.name + " on interface prototype object");
        }
        else if (member.type == "attribute")
        {
            test(function() {
                assert_own_property(window, interface_obj.name,
                                    "window does not have own property " + format_value(interface_obj.name));
                assert_own_property(window[interface_obj.name], "prototype",
                                    'interface "' + interface_obj.name + '" does not have own property "prototype"');

                //"For each attribute defined on the interface, there must
                //exist a corresponding property. If the attribute was
                //declared with the [Unforgeable] extended attribute, then
                //the property exists on every object that implements the
                //interface.  Otherwise, it exists on the interface’s
                //interface prototype object."
                if (!member.has_extended_attribute("Unforgeable"))
                {
                    assert_own_property(window[interface_obj.name].prototype, member.name);
                }

                //"The property has attributes { [[Get]]: G, [[Set]]: S,
                //[[Enumerable]]: true, [[Configurable]]: configurable },
                //where:
                //"configurable is false if the attribute was declared with
                //the [Unforgeable] extended attribute and true otherwise;
                //"G is the attribute getter, defined below; and
                //"S is the attribute setter, also defined below."
                var desc = Object.getOwnPropertyDescriptor(window[interface_obj.name].prototype, member.name);
                assert_true(desc.enumerable, "property is not enumerable");
                if (member.has_extended_attribute("Unforgeable"))
                {
                    assert_false(desc.configurable, "[Unforgeable] property must not be configurable");
                }
                else
                {
                    assert_true(desc.configurable, "property must be configurable");
                }
                //"The attribute getter is a Function object whose behavior
                //when invoked is as follows:
                //"...
                //"The value of the Function object’s “length” property is
                //the Number value 0."
                assert_equals(typeof desc.get, "function", "getter must be Function");
                assert_equals(desc.get.length, 0, "getter length must be 0");
                //"The attribute setter is undefined if the attribute is
                //declared readonly and has neither a [PutForwards] nor a
                //[Replaceable] extended attribute declared on it.
                //Otherwise, it is a Function object whose behavior when
                //invoked is as follows:
                //"...
                //"The value of the Function object’s “length” property is
                //the Number value 1."
                if (member.readonly
                && !member.has_extended_attribute("PutForwards")
                && !member.has_extended_attribute("Replaceable"))
                {
                    assert_equals(desc.set, undefined, "setter must be undefined for readonly attributes");
                }
                else
                {
                    assert_equals(typeof desc.set, "function", "setter must be function for PutForwards, Replaceable, or non-readonly attributes");
                    assert_equals(desc.set.length, 1, "setter length must be 1");
                }
            }, this.name + " interface: attribute " + member.name);
        }
        else if (member.type == "operation")
        {
            //TODO: Need to correctly handle multiple operations with the
            //same identifier.
            if (!member.name)
            {
                //Unnamed getter or such
                continue;
            }
            test(function() {
                assert_own_property(window, interface_obj.name,
                                    "window does not have own property " + format_value(interface_obj.name));
                assert_own_property(window[interface_obj.name], "prototype",
                                    'interface "' + interface_obj.name + '" does not have own property "prototype"');

                //"For each unique identifier of an operation defined on
                //the interface, there must be a corresponding property on
                //the interface prototype object (if it is a regular
                //operation) or the interface object (if it is a static
                //operation), unless the effective overload set for that
                //identifier and operation and with an argument count of 0
                //(for the ECMAScript language binding) has no entries."
                //TODO: The library doesn't seem to support static
                //operations.
                assert_own_property(window[interface_obj.name].prototype, member.name,
                    "interface prototype object missing non-static operation");

                var desc = Object.getOwnPropertyDescriptor(window[interface_obj.name].prototype, member.name);
                //"The property has attributes { [[Writable]]: true,
                //[[Enumerable]]: true, [[Configurable]]: true }."
                assert_true(desc.writable, "property must be writable");
                assert_true(desc.enumerable, "property must be enumerable");
                assert_true(desc.configurable, "property must be configurable");
                //"The value of the property is a Function object whose
                //behavior is as follows . . ."
                assert_equals(typeof window[interface_obj.name].prototype[member.name], "function",
                              "property must be a function");
                //"The value of the Function object’s “length” property is
                //a Number determined as follows:
                //". . .
                //"Return the maximum argument list length of the functions
                //in the entries of S."
                assert_equals(window[interface_obj.name].prototype[member.name].length, member.arguments.length,
                    "property has wrong .length");
            }, this.name + " interface: operation " + member.name);
        }
    }
}
})();
// vim: set expandtab shiftwidth=4 tabstop=4:
