<!doctype html>
<!-- Note: this is a test for DOM Range, not HTML5.  It will probably be moved
someplace else. -->
<title>Selection direction tests</title>
<meta charset=utf-8>
<style>div > p:not(:first-child) { font-family: monospace }</style>
<p>This is a manual test, since there's no way to synthesize keyboard or mouse
input programmatically.  Follow the bolded instructions for each part, then
click the "Test" button to continue.

<div id=test1>
	<p><strong>Click after the letter "c" in the following paragraph and drag
	backwards so that both the "b" and the "c" are highlighted, then click the
	"Test" button:</strong>

	<p>abcdefg

	<p>hijklmn

	<p>opqrstu

	<p>vwxyz01

	<p><button onclick=test1()>Test 1/3</button>
</div>
<div id=test2 style=display:none>
	<p><strong>Click after the letter "i" two paragraphs below, then drag
	backwards so that "fghi" are all highlighted (straddling two paragraphs),
	then click the "Test" button:</strong>

	<p>abcdefg

	<p>hijklmn

	<p>opqrstu

	<p>vwxyz01

	<p><button onclick=test2()>Test 2/3</button>
</div>
<div id=test3 style=display:none>
	<p><strong>Click in between the two Hebrew letters ("א" and "ב") on the
	line below, then drag to the left of "b".  The letters "א" and "b" should
	both be selected, so that there's a gap in the selection ("ב" should not be
	selected).  Then click the "Test" button:</strong>

	<p>abאבfg

	<p>hijklmn

	<p>opqrstu

	<p>vwxyz01

	<p><button onclick=test3()>Test 3/3</button>
</div>
<div id=log></div>
<script src=../../resources/testharness.js></script>
<script src=../../resources/testharnessreport.js></script>
<script>
var selection, range, expectedAnchorNode, expectedAnchorOffset,
	expectedFocusNode, expectedFocusOffset, expectedDirection;

function testSelectionNodes() {
	assert_equals(selection.anchorNode, expectedAnchorNode);
	assert_equals(selection.focusNode, expectedFocusNode);
}
function testSelectionOffsetsUnordered() {
	var actualOffsets = [selection.anchorOffset, selection.focusOffset].sort();
	var expectedOffsets = [expectedAnchorOffset, expectedFocusOffset].sort();
	assert_equals(actualOffsets[0], expectedOffsets[0]);
	assert_equals(actualOffsets[1], expectedOffsets[1]);
}
function testSelectionOffsetsOrdered() {
	assert_equals(selection.anchorOffset, expectedAnchorOffset);
	assert_equals(selection.focusOffset, expectedFocusOffset);
}
function testSelectionDirection() {
	if (expectedDirection == "backwards") {
		assert_equals(selection.anchorNode, range.endContainer);
		assert_equals(selection.anchorOffset, range.endOffset);
		assert_equals(selection.focusNode, range.startContainer);
		assert_equals(selection.focusOffset, range.startOffset);
	} else if (expectedDirection == "forwards") {
		assert_equals(selection.anchorNode, range.startContainer);
		assert_equals(selection.anchorOffset, range.startOffset);
		assert_equals(selection.focusNode, range.endContainer);
		assert_equals(selection.focusOffset, range.endOffset);
	} else {
		// Test bug?
		assert_true(false);
	}
}

function test1() {
	expectedAnchorNode = expectedFocusNode = document.querySelector("#test1 > p + p").firstChild;
	expectedAnchorOffset = 3;
	expectedFocusOffset = 1;
	expectedDirection = "backwards";
	doTest(1);
}
function test2() {
	expectedAnchorNode = document.querySelector("#test2 > p + p + p").firstChild;
	expectedAnchorOffset = 2;
	expectedFocusNode = document.querySelector("#test2 > p + p").firstChild;
	expectedFocusOffset = 5;
	expectedDirection = "backwards";
	doTest(2);
}
function test3() {
	expectedAnchorNode = expectedFocusNode = document.querySelector("#test3 > p + p").firstChild;
	expectedAnchorOffset = 3;
	expectedFocusOffset = 1;
	expectedDirection = "backwards";
	doTest(3);
}

function doTest(num) {
	var testDiv = document.getElementById("test" + num);
	selection = getSelection();
	// Spec says the last Range is the one that counts
	range = selection.getRangeAt(selection.rangeCount - 1);
	runSubtests(num, "initially");

	// Per spec, the direction of the selection remains even if you zap a range
	// and add a new one.
	test(function() {
		selection.removeRange(range);
		range = document.createRange();
		expectedAnchorNode = expectedFocusNode = testDiv.getElementsByTagName("p")[2].firstChild;
		expectedAnchorOffset = 4;
		expectedFocusOffset = 0;
		// Since the selection is backwards, we send the anchor at the end and
		// the focus at the start.
		range.setEnd(expectedAnchorNode, expectedAnchorOffset);
		range.setStart(expectedFocusNode, expectedFocusOffset);
		selection.addRange(range);
	}, "Test " + num + ": removeRange()/addRange() successful");
	runSubtests(num, "after remove/addRange()");

	// If we add a second range, that should be the one that everything tracks,
	// but still backwards.
	test(function() {
		range = document.createRange();
		expectedAnchorNode = expectedFocusNode = testDiv.getElementsByTagName("p")[3].firstChild;
		expectedAnchorOffset = 7;
		expectedFocusOffset = 6;
		range.setEnd(expectedAnchorNode, expectedAnchorOffset);
		range.setStart(expectedFocusNode, expectedFocusOffset);
		selection.addRange(range);
	}, "Test " + num + ": Second addRange() successful");
	runSubtests(num, "after second addRange()");

	// Now test a range that spans multiple elements.
	test(function() {
		expectedAnchorNode = testDiv.getElementsByTagName("p")[4].firstChild;
		expectedFocusNode = testDiv.getElementsByTagName("p")[2].firstChild;
		expectedAnchorOffset = 5;
		expectedFocusOffset = 1;
		range.setEnd(expectedAnchorNode, expectedAnchorOffset);
		range.setStart(expectedFocusNode, expectedFocusOffset);
	}, "Test " + num + ": updating range to span multiple elements successful");
	runSubtests(num, "with multiple elements");

	// But if you call removeAllRanges(), the direction should reset to
	// forwards.
	test(function() {
		selection.removeAllRanges();
		range = document.createRange();
		expectedAnchorNode = expectedFocusNode = testDiv.getElementsByTagName("p")[4].firstChild;
		expectedAnchorOffset = 2;
		expectedFocusOffset = 5;
		expectedDirection = "forwards";
		// Now the anchor should be at the start and the focus at the end.
		range.setStart(expectedAnchorNode, expectedAnchorOffset);
		range.setEnd(expectedFocusNode, expectedFocusOffset);
		selection.addRange(range);
	}, "Test " + num + ": removeAllRanges() successful");
	runSubtests(num, "after removeAllRanges()");

	testDiv.style.display = "none";
	var nextDiv = document.getElementById("test" + (num + 1));
	if (nextDiv) {
		nextDiv.style.display = "block";
	}
	scroll(0, 0);
}

function runSubtests(num, desc) {
	test(testSelectionNodes, "Test " + num + ": Expected nodes are selected " + desc);
	test(testSelectionOffsetsUnordered, "Test " + num + ": Expected offsets are selected " + desc + " (maybe not in order)");
	test(testSelectionOffsetsOrdered, "Test " + num + ": Expected offsets are selected " + desc + " (in order)");
	test(testSelectionDirection, "Test " + num + ": Nodes/offsets are " + expectedDirection + " " + desc);
}
</script>
