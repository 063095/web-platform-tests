<!doctype html>
<!-- Note: this is a test for DOM Range, not HTML5.  It will probably be moved
someplace else. -->
<title>Selection direction tests</title>
<meta charset=utf-8>
<div id=test>
	<p>This is a manual test, since there's no way to synthesize keyboard or
	mouse input.  Click after the letter "c" in the following paragraph and
	drag backwards so that both the "b" and the "c" are highlighted, then click
	the "Test" button:

	<p>abcd <button onclick=testDirection()>Test</button>

	<p>efghi
</div>
<div id=log></div>
<script src=../../resources/testharness.js></script>
<script src=../../resources/testharnessreport.js></script>
<script>
function testDirection() {
	var testDiv = document.getElementById("test");
	var p = testDiv.getElementsByTagName("p")[1].firstChild;
	var selection = getSelection();
	// Spec says the last Range is the one that counts
	var range = selection.getRangeAt(selection.rangeCount - 1);
	test(function() {
		assert_equals(selection.anchorNode, p);
		assert_equals(selection.focusNode, p);
	}, "Expected node is initially selected");
	test(function() {
		var actualOffsets = [selection.anchorOffset, selection.focusOffset].sort();
		var expectedOffsets = [1, 3].sort();
		assert_equals(actualOffsets[0], expectedOffsets[0]);
		assert_equals(actualOffsets[1], expectedOffsets[1]);
	}, "Expected offsets are initially selected (maybe not in order)");
	test(function() {
		assert_equals(selection.anchorNode, range.endContainer);
		assert_equals(selection.anchorOffset, range.endOffset);
		assert_equals(selection.focusNode, range.startContainer);
		assert_equals(selection.focusOffset, range.startOffset);
	}, "Offsets are backwards for initial selection");

	// Per spec, the direction of the selection remains even if you zap a range
	// and add a new one.
	test(function() {
		selection.removeRange(range);
		range = document.createRange();
		p = testDiv.getElementsByTagName("p")[0].firstChild;
		range.setStart(p, 0);
		range.setEnd(p, 4);
		selection.addRange(range);
	}, "removeRange()/addRange() successful");
	test(function() {
		assert_equals(selection.anchorNode, p);
		assert_equals(selection.focusNode, p);
	}, "Expected node is selected after remove/addRange()");
	test(function() {
		var actualOffsets = [selection.anchorOffset, selection.focusOffset].sort();
		var expectedOffsets = [0, 4].sort();
		assert_equals(actualOffsets[0], expectedOffsets[0]);
		assert_equals(actualOffsets[1], expectedOffsets[1]);
	}, "Expected offsets are selected after remove/addRange() (maybe not in order)");
	test(function() {
		assert_equals(selection.anchorNode, range.endContainer);
		assert_equals(selection.anchorOffset, range.endOffset);
		assert_equals(selection.focusNode, range.startContainer);
		assert_equals(selection.focusOffset, range.startOffset);
	}, "Offsets are backwards after remove/addRange()");

	// But if you call removeAllRanges(), the direction should reset to
	// forwards.
	test(function() {
		selection.removeAllRanges();
		range = document.createRange();
		p = testDiv.getElementsByTagName("p")[2].firstChild;
		range.setStart(p, 2);
		range.setEnd(p, 5);
		selection.addRange(range);
	}, "removeAllRanges() successful");
	test(function() {
		assert_equals(selection.anchorNode, p);
		assert_equals(selection.focusNode, p);
	}, "Expected node is selected after removeAllRanges()");
	test(function() {
		var actualOffsets = [selection.anchorOffset, selection.focusOffset].sort();
		var expectedOffsets = [2, 5].sort();
		assert_equals(actualOffsets[0], expectedOffsets[0]);
		assert_equals(actualOffsets[1], expectedOffsets[1]);
	}, "Expected offsets are selected after removeAllRanges() (maybe not in order)");
	test(function() {
		assert_equals(selection.anchorNode, range.startContainer);
		assert_equals(selection.anchorOffset, range.startOffset);
		assert_equals(selection.focusNode, range.endContainer);
		assert_equals(selection.focusOffset, range.endOffset);
	}, "Offsets are forwards after removeAllRanges()");
}
</script>
