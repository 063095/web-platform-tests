<!DOCTYPE html>
<html>
<title>Service Workers: Concepts</title>
    <head>
        <link rel="help" href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#concepts">
        <script src="/resources/testharness.js"></script>
        <script src="/resources/testharnessreport.js"></script>
    
    </head>
    <body>

<!--

A Service Worker is a type of [Web Worker][1]. Unlike other types of Web
Worker, the lifetime of a Service Worker is tied to the execution lifetime of
events, not references held by documents to the [worker object][2]. In
practice, this means that [Service Workers][3] may begin, end, and restart
execution many times over the life of documents which they logically
[control][4].

Service Workers are [installed][5] by user agents after being [registered][6]
by authors from the context of a [document][7]. Service Workers execute in the
registering document's [origin][8].

Registration maps a [Service Worker][3] script to URL scope, a tuple of
[origin][9] and [path expression][10]. User agents may enable many
registrations at a single origin so long as the [path expression][10] of the
registration differs. [Registration][11] of an identical [origin][9]/[path
expression][10] when one already exists in the user agent causes the existing
registration to be replaced.

A [registration][11] may have an associated installing worker, which is a
Service Worker, for the [registration][11], which has entered and is running
the steps in the [installation process][12], and an associated active worker,
which is a Service Worker, for the [registration][11], which has entered and
may have completed the [activation process][13].

A path expression consists of a [relative URL][14] which may, optionally,
terminate with the character `"*"`. Ending a [path expression][10] with `"*"`
enables [longest-prefix wildcard matching][15].

A document is controlled if an [active worker][16] [matches][15] the document's
URL upon [navigation][17]. Multiple documents may be concurrently
[controlled][4] by a single [Service Worker][3] instance. That is, [Service
Workers][3] have a one-to-many relationship with [controlled][4] documents.

The Lifecycle events of Service Workers are `[install][18]` and
`[activate][19]`. Functional events are [DOM Events][20] that are dispatched in
the [Service Worker global context][21] which are not [lifecycle events][22] of
the Service Worker.

Registered Service Workers do not immediately begin to receive [functional
events][23] for documents. [Registration][24] is the first step in
installation, which proceeds through several phases:

1.  _Fetch_:
     The script URL provided by the author (via a call to
    [`navigator.serviceWorker.register([script URL], [registration
    option])`][6] from a document) is fetched without [heuristic
    caching][25]. If the return status code of the fetch is not [2xx][26],
    installation aborts.
2.  _Startup_:
     If fetching the worker script is successful, it is [executed][27] in a
    `[ServiceWorkerGlobalScope][21]`. These scripts may call
    `[importScripts][28]` resulting in further fetches. Imported scripts
    are fetched, [parsed][29] and [executed][30] in turn, per the ECMA-262
    and [Web Worker specifications][28]. All resources downloaded as part
    of the very first startup of a Service Worker are cached along with the
    worker script as described in ["Worker Script Caching"][31].
3.  _`oninstall`_:
     Once a Service Worker has been fetched and started, it is ready to
    process [events][20]. The first event sent to every Service Worker is
    [`install`][18]. Workers that handle this event are encouraged to use
    it as a way to prime the available storage mechanisms for supporting
    offline application use; perhaps by populating [IndexedDB
    databases][32] or [`Cache` objects][33].
    
     Service Workers are not considered "installed" until the `oninstall`
    event handler completes. Given that many tasks, such as populating
    caches, may take a long time and are asynchronous, [mechanisms are
    provided][34] to let applications signal to the user agent when they
    consider themselves prepared to handle further events.
        
    
     If no `oninstall` event handler is registered, the Service Worker is
    considered to be successfully installed.
        
    
     If any `oninstall` handler throws an exception, or if any lifetime
    extension via `event.waitUntil()` fails (via Promise rejection),
    installation fails and activation is not carried out.
        
    
     Assuming an [installing worker][35] completes the steps in the
    [installation process][12] (i.e. succesfully installed), it is now
    considered the worker in waiting. There may be only one [active
    worker][16], one [worker in waiting][36] and one [installing
    worker][35] for a given [URL scope][37].
4.  _`onactivate`_:
     After successful installation and just prior to receiving [functional
    events][23] (e.g., `[fetch][38]`), the `activate` event is dispatched.
    The primary use of `onactivate` is for cleanup of resources used in
    previous versions of a Service Worker script.
        
    
    Like `install` event, this event may extend its lifetime using
    `event.waitUntil()`, however developers should note that activation is
    particularly performance sensitive. Performance sensitive events may be
    queued and will be delayed until successful completion of `onactivate`.
User Agents may request updated Service Worker scripts "in the background"
while [controlled][4] documents for an existing Service Worker and URL scope
are active. Successful fetch, startup, and `oninstall` _do not_ guarantee that
the [worker-in-waiting][36] will begin to immediately handle [functional
events][23]. An existing Service Worker script will continue to service
documents it controls (and will continue to control new documents in the [URL
scope][37]) so long as any documents it [controlled][4] remain. API exists on
the [Service Worker][2] to enable immediate activation but this is not the
default behavior.



Once a Service Worker becomes active, the user agent may dispatch [functional
events][23]. These events model various user-agent generated operations; for
example the `[fetch][38]` event handling HTTP requests.



[1]: http://www.w3.org/TR/workers/
[2]: #service-worker-obj
[3]: #service-worker
[4]: #document-control
[5]: #installation-algorithm
[6]: #navigator-service-worker-register
[7]: http://dom.spec.whatwg.org/#concept-document
[8]: http://goo.gl/58tlSE
[9]: http://tools.ietf.org/html/rfc6454
[10]: #path-expression
[11]: #registration
[12]: #installation-process
[13]: #activation-process
[14]: http://url.spec.whatwg.org/#concept-relative-url
[15]: #scope-match-algorithm
[16]: #active-worker
[17]: http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#navigate
[18]: #install-event
[19]: #activate-event
[20]: http://dom.spec.whatwg.org/#interface-event
[21]: #service-worker-global-scope
[22]: #lifecycle-events
[23]: #functional-events
[24]: #registration-algorithm
[25]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.2.2
[26]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2
[27]: http://www.w3.org/TR/workers/#processing-model
[28]: http://www.w3.org/TR/workers/#importing-scripts-and-libraries
[29]: https://people.mozilla.org/~jorendorff/es5.1-final.html#sec-5.1.4
[30]: https://people.mozilla.org/~jorendorff/es5.1-final.html#sec-10.4.1
[31]: #update-algorithm
[32]: http://www.w3.org/TR/IndexedDB/
[33]: #cache-objects
[34]: #wait-until-method
[35]: #installing-worker
[36]: #worker-in-waiting
[37]: #url-scope
[38]: #fetch-event

-->



    <script>
        test(function() {
            // not_implemented();
        }, "There are no tests for section Concepts so far.");
    </script>

    </body>
</html>

