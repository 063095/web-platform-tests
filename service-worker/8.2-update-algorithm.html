<!DOCTYPE html>
<html>
<title>Service Workers: _Update</title>
    <head>
        <link rel="help" href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#update-algorithm">
        <script src="/resources/testharness.js"></script>
        <script src="/resources/testharnessreport.js"></script>
    
    </head>
    <body>

<!--

The [Service Worker _Update Algorithm][1], run by the user agent, upgrades an
[active worker][2] to a new version for the same [URL scope][3]. If successful,
the newly installed Service Worker becomes the [worker in waiting][4] which
later becomes the [active worker][2] as soon as all the documents served by the
previous Service Worker are closed. When scheduling a fetch of a new version,
the user agent should honor the HTTP cache headers with the upper limit of 24
hours:

Input:
    `serviceWorkerRegistration`, a [_ServiceWorkerRegistration][5] object
Output:
    `promise`, a [promise][6] whose resolution indicates the success or failure
    of the algorithm
1.  If `serviceWorkerRegistration`.`updatePromise` is not null, then:
    1.  Reject `serviceWorkerRegistration`.`updatePromise` with a new
        `AbortError`.
    2.  The browser may abort in-flight requests, parsing or worker
        execution relating to `serviceWorkerRegistration`.`updatePromise`.
2.  If `serviceWorkerRegistration`.`installingWorker` is not null, then:
    1.  Terminate `serviceWorkerRegistration`.`installingWorker`.
    2.  Run the [_UpdateState algorithm][7] passing
        `serviceWorkerRegistration`.`installingWorker` and `redundant` as
        the arguments.
    3.  Set `serviceWorkerRegistration`.`installingWorker` to null.
    4.  The user agent may abort any in-flight requests triggered by
        `serviceWorkerRegistration`.`installingWorker`.
3.  Let `promise` be a newly-created [promise][6].
4.  Set `serviceWorkerRegistration`.`updatePromise` to `promise`.
5.  Return `promise`.
6.  Run the following steps asynchronously:
    1.  Perform a fetch of `serviceWorkerRegistration`.`scriptUrl`, forcing
        a network fetch if cached entry is greater than 1 day old.
    2.  If `promise` has been rejected (eg, another registration has
        aborted it), then:
        1.  Set `serviceWorkerRegistration`.`updatePromise` to null.
        2.  Abort these steps.
    3.  Else if fetching the script fails due to the server returning a 4xx
        response or a 5xx response, or there is a DNS error, or the
        connection times out, then:
        1.  Reject `promise` with a new `NetworkError`.
        2.  Set `serviceWorkerRegistration`.`updatePromise` to null.
        3.  Abort these steps.
    4.  Else if the server returned a redirect, then:
        1.  Reject `promise` with a new `SecurityError`.
        2.  Set `serviceWorkerRegistration`.`updatePromise` to null.
        3.  Abort these steps.
    5.  Let `fetchedScript` be the fetched script.
    6.  Let newestWorker be the result of running the [_GetNewestWorker
        algorithm][8] passing `serviceWorkerRegistration` as the argument.
    7.  If `newestWorker` is not null, and `newestWorker`.`url` is equal to
        `serviceWorkerRegistration`.`scriptUrl` and `fetchedScript` is a
        byte-for-byte match with the script of `newestWorker`, then:
        1.  Resolve `promise` with `newestWorker`.
        2.  Set `serviceWorkerRegistration`.`updatePromise` to null.
        3.  Abort these steps.
    8.  Else,
        1.  Let `serviceWorker` be a newly-created [ServiceWorker][9]
            object, using `fetchedScript`.
        2.  If `promise` has been rejected (e.g, another registration has
            aborted it), then:
            1.  Set `serviceWorkerRegistration`.`updatePromise` to null.
            2.  Abort these steps.
        3.  If `serviceWorker` fails to start up, due to parse errors or
            uncaught errors, then:
            1.  Reject `promise` with the error.
            2.  Set `serviceWorkerRegistration`.`updatePromise` to null.
            3.  Abort these steps.
        4.  Resolve `promise` with `serviceWorker`.
        5.  Set `serviceWorkerRegistration`.`updatePromise` to null.
        6.  Queue a task to invoke [_Installation algorithm][10] with
            `serviceWorkerRegistration` and `serviceWorker` as its
            arguments.



[1]: #update-algorithm
[2]: #active-worker
[3]: #url-scope
[4]: #worker-in-waiting
[5]: #service-worker-registration-internal-interface
[6]: http://goo.gl/3TobQS
[7]: #update-state-algorithm
[8]: #get-newest-worker-algorithm
[9]: #service-worker-interface
[10]: #installation-algorithm

-->



    <script>
        test(function() {
            // not_implemented();
        }, "There are no tests for section _Update so far.");
    </script>

    </body>
</html>

