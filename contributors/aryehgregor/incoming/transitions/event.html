<!doctype html>
<title>CSS Transitions event tests</title>
<link rel=author title="Aryeh Gregor" href="ayg@aryeh.name">
<script src=/resources/testharness.js></script>
<script src=http://w3c-test.org/resources/testharnessreport.js></script>
<style>
#tests { width: 200px }
#tests > div {
	height: 3px;
	background: blue;
	border: 1px solid black;
}
</style>
<div id=tests></div>
<div id=log></div>
<script>
"use strict";

var prop = "transition" in document.body.style ? "transition"
	: "msTransition" in document.body.style ? "msTransition"
	: "MozTransition" in document.body.style ? "MozTransition"
	: "webkitTransition" in document.body.style ? "webkitTransition"
	: "OTransition" in document.body.style ? "OTransition"
	: undefined;

if (prop === undefined) {
	throw "Transitions not supported?";
}

add_completion_callback(function() {
	document.body.removeChild(document.querySelector("#tests"));
});

var testTypes = {
	color: {
		start: "green",
		end: "blue",
		startValues: [0, 128, 0],
		endValues: [0, 0, 255],
		computedFormat: ["rgb($, $, $)", "rgba($, $, $, 1)"],
	},
	length: {
		start: "50px",
		end: "100px",
		startValues: [50],
		endValues: [100],
		computedFormat: ["$px"],
	},
	// TODO: add percentage
	lengthOrPercentage: {
		start: "50px",
		end: "100px",
		startValues: [50],
		endValues: [100],
		computedFormat: ["$px"],
	},
	position: {
		start: "24% 72px",
		end: "103% -5px",
		startValues: [24, 72],
		endValues: [103, -5],
		computedFormat: ["$% $px"],
	},
	twoLengths: {
		start: "50px 75px",
		end: "100px 25px",
		startValues: [50, 75],
		endValues: [100, 25],
		computedFormat: ["$px $px"],
	},
};

// TODO: Shorthands
var tests = {
	"background-color": testTypes.color,
	"background-position": testTypes.position,
	"border-bottom-color": testTypes.color,
	"border-bottom-width": testTypes.length,
	"border-left-color": testTypes.color,
	"border-left-width": testTypes.length,
	"border-right-color": testTypes.color,
	"border-right-width": testTypes.length,
	"border-spacing": testTypes.twoLengths,
	"border-top-color": testTypes.color,
	"border-top-width": testTypes.length,
	"bottom": testTypes.lengthOrPercentage,
	"clip": {
		start: "rect(-10px, 110px, 110px, -10px)",
		end: "rect(25px, 75px, 75px, 25px)",
		startValues: [-10, 110, 110, -10],
		endValues: [25, 75, 75, 25],
		computedFormat: ["rect($px, $px, $px, $px)", "rect($px $px $px $px)"],
	},
	"color": testTypes.color,
	"font-size": testTypes.lengthOrPercentage,
	"height": testTypes.lengthOrPercentage,
	"left": testTypes.lengthOrPercentage,
	"letter-spacing": testTypes.length,
	// TODO: Add number too
	"line-height": testTypes.lengthOrPercentage,
	"margin-bottom": testTypes.length,
	"margin-left": testTypes.length,
	"margin-right": testTypes.length,
	"margin-top": testTypes.length,
	"max-height": testTypes.lengthOrPercentage,
	"max-width": testTypes.lengthOrPercentage,
	"min-height": testTypes.lengthOrPercentage,
	"min-width": testTypes.lengthOrPercentage,
	"opacity": {
		start: "1",
		end: "0",
		startValues: "1",
		endValues: "0",
		computedFormat: ["$"],
		tolerance: 0.05,
	},
	"outline-color": testTypes.color,
	"outline-offset": testTypes.length,
	"outline-width": testTypes.length,
	"padding-bottom": testTypes.length,
	"padding-left": testTypes.length,
	"padding-right": testTypes.length,
	"padding-top": testTypes.length,
	"right": testTypes.lengthOrPercentage,
	"text-indent": testTypes.lengthOrPercentage,
	// TODO: text-shadow
	"top": testTypes.lengthOrPercentage,
	// TODO: keywords
	"vertical-align": testTypes.lengthOrPercentage,
	// TODO: visibility
	"width": testTypes.lengthOrPercentage,
	"word-spacing": testTypes.lengthOrPercentage,
	// TODO: z-index
};

function getExpectedValues(timing, elapsed, startValues, endValues) {
	if (elapsed < 0) {
		elapsed = 0;
	} else if (elapsed > 1) {
		elapsed = 1;
	}
	// Linear only for now
	var ret = [];
	for (var i = 0; i < startValues.length; i++) {
		ret.push((1 - elapsed)*startValues[i] + elapsed*endValues[i]);
	}
	return ret;
}

function parseComputedValue(formats, computed) {
	if (formats.indexOf("$") != -1) {
		// That always works . . .
		return [Number(computed)];
	}
	for (var i = 0; i < formats.length; i++) {
		var format = formats[i].split("$");
		var ret = [];
		for (var j = 0; j < format.length; j++) {
			var idx = computed.indexOf(format[j]);
			if (idx == -1) {
				// Wrong format
				break;
			}
			if (j != 0) {
				ret.push(Number(computed.substr(0, idx)));
			}
			computed = computed.substr(idx + format[j].length);
		}
		if (computed == "") {
			// Success
			return ret;
		}
	}
	return null;
}

function substitute(arr, values) {
	return arr.map(function(s) {
		for (var i = 0; i < values.length; i++) {
			s = s.replace("$", values[i]);
		}
		return s;
	});
}

Object.keys(tests).forEach(function(testProp) {
	var duration = 2;
	var delay = 1;
	var timing = "linear";
	var steps = 4;

	var data = tests[testProp];

	var div = document.createElement("div");
	document.querySelector("#tests").appendChild(div);
	div.style.setProperty(testProp, data.start);
	if (testProp == "outline-width") {
		// Special case, to be generalized when necessary
		div.style.outlineStyle = "solid";
	}
	div.style[prop] = testProp + " " + duration + "s " + delay + "s " + timing;

	var t = async_test(testProp + " " + duration + "s " + delay + "s " + timing
		+ " from " + data.start + " to " + data.end,
		{timeout: 1000*(duration+delay+1)});
	t.step(function() {
		assert_in_array(
			getComputedStyle(div).getPropertyValue(testProp),
			substitute(data.computedFormat, data.startValues),
			"Computed style wrong before we even began"
		);
	});

	(function(div, t, testProp, data) {
		var handler = function(e) {
			t.step(function() {
				assert_equals(this, div, "this");
				//assert_equals(e.type, "transitionend", "event.type");
				assert_equals(e.target, div, "event.target");
				assert_equals(e.currentTarget, div, "event.currentTarget");
				assert_equals(e.eventPhase, Event.AT_TARGET,
					"event.eventPhase");
				assert_equals(e.bubbles, true, "event.bubbles");
				assert_equals(e.cancelable, true, "event.cancelable");
				assert_equals(e.propertyName, testProp, "event.propertyName");
				assert_approx_equals(e.elapsedTime, duration, 0.001,
					"event.elapsedTime");
				assert_in_array(
					getComputedStyle(div).getPropertyValue(testProp),
					substitute(data.computedFormat, data.endValues),
					"Computed style wrong at transitionend"
				);
			}.bind(this));

			t.done();
		};
		div.addEventListener("transitionend", handler);
		div.addEventListener("MSTransitionEnd", handler);
		div.addEventListener("webkitTransitionEnd", handler);
		div.addEventListener("oTransitionEnd", handler);

		var startTime;

		setTimeout(function() {
			startTime = Date.now();
			div.style.setProperty(testProp, data.end);
			t.step(function() {
				assert_in_array(
					getComputedStyle(div).getPropertyValue(testProp),
					substitute(data.computedFormat, data.startValues),
					"Computed style wrong after setting new property"
				);
			});
		}, 50);

		for (var i = 1; i <= steps; i++) {
			(function(i) {
				var elapsed = delay + i*duration/steps;
				setTimeout(function() {
					t.step(function() {
						var actualElapsed = (Date.now() - startTime)/1000;
						assert_approx_equals(actualElapsed, elapsed, 0.25,
							"Elapsed time is further off than we want");
						var computed = getComputedStyle(div).getPropertyValue(testProp);
						var parsed = parseComputedValue(data.computedFormat,
							computed);
						assert_not_equals(parsed, null,
							"Invalid format for computed style " + computed +
							" after " + elapsed + "s");
						var expected = getExpectedValues(timing,
							(actualElapsed - delay)/duration,
							data.startValues, data.endValues);
						for (var j = 0; j < parsed.length; j++) {
							assert_approx_equals(parsed[j], expected[j],
								"tolerance" in data ? data.tolerance : 3,
								"Value " + j + " is wrong " +
								"after " + elapsed + "s " +
								"(really " + actualElapsed + "s): " +
								"expected " + format_value(expected) + ", " +
								"got " + computed + " " +
								"(= " + format_value(parsed) + ")");
						}
					});
				}, 50 + 1000*elapsed);
			})(i);
		}
	})(div, t, testProp, data);
});
</script>
