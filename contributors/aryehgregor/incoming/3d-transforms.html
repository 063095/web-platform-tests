<!doctype html>
<title>CSS 3D Transforms tests</title>
<link rel=author title="Aryeh Gregor" href="ayg@aryeh.name">
<script src=http://w3c-test.org/resources/testharness.js></script>
<script src=http://w3c-test.org/resources/testharnessreport.js></script>
<style>
/* See 2d-transforms.html for info on styles, which are copy-pasted for now */
body {
	margin: -15px;
	width: 130px;
	height: 80px;
}
body > div {
	width: 120px;
	height: 70px;
	padding: 5px;
	background: orange;
}
body > div > div {
	width: 110px;
	height: 60px;
	padding: 5px;
	background: yellow;
}
body, div {
	position: relative;
}
#test {
	position: static;
	height: 30px;
	width: 80px;
	padding: 5px;
	border: 5px solid black;
	margin: 5px;
	background: blue;
}
#log { display: none }
</style>
<style class=switch></style>
<style class=switch>
div { float: left }
</style>
<style class=switch>
div { float: right }
</style>
<style class=switch>
div { float: right }
body { width: 180px; margin-left: -65px }
</style>
<style class=switch>
#test { position: absolute }
</style>
<style class=switch>
body > div > div { border-right: 10px solid transparent; width: 100px }
#test { position: absolute; right: -5px }
</style>
<style class=switch>
body > div > div { padding-left: 10px; width: 105px }
#test { position: relative; left: -5px }
</style>
<style class=switch>
#test { display: inline-block }
</style>
<style class=switch>
#test { display: table }
</style>
<div><div><div id=test></div></div></div>
<div id=log></div>
<script src="transforms.js"></script>
<script>
"use strict";

// Test case-sensitivity
[
	// FIXME: The spec doesn't match browsers for serialization of the
	// transform property when it's unset or "none".
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15471
	// [["none", "NONE", "nOnE"], 1, 0, 0, 1, 0, 0],
	[["matrix3d(1,2,3,0,4,5,6,0,7,8,9,0,10,11,12,1)",
	  "MATRIX3D(1,2,3,0,4,5,6,0,7,8,9,0,10,11,12,1)",
	  "mAtRiX3d(1,2,3,0,4,5,6,0,7,8,9,0,10,11,12,1)"],
	 1, 2, 3, 0,  4, 5, 6, 0,  7, 8, 9, 0,  10, 11, 12, 1],
	[["translate3d(21px, -6px, 4px)",
	  "TRANSLATE3D(21PX, -6PX, 4PX)",
	  "tRaNsLaTe3D(21pX, -6pX, 4pX)"],
	 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  21, -6, 4, 1],
	[["translatez(15.4px)","TRANSLATEZ(15.4PX)",  "tRaNsLaTeZ(15.4pX)"],
	 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, 0,  0, 0, 15.4, 1],
	[["scale3d(2, 4, -9)","SCALE3D(2, 4, -9)",  "sCaLe3D(2, 4, -9)"],
	 2, 0, 0, 0,  0, 4, 0, 0,  0, 0, -9, 0,  0, 0, 0, 1],
	[["scalez(2)","SCALEZ(2)",  "sCaLeZ(2)"],
	 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 2, 0,  0, 0, 0, 1],
	[["rotate3d(0, 0, 1, 180deg)",
	  "ROTATE3D(0, 0, 1, 180DEG)",
	  "rOtAtE3d(0, 0, 1, 180DeG)"],
	 -1, 0, 0, 0,  0, -1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1],
	[["rotatex(180deg)",
	  "ROTATEX(180DEG)",
	  "rOtAtEx(180DeG)"],
	 1, 0, 0, 0,  0, -1, 0, 0,  0, 0, -1, 0,  0, 0, 0, 1],
	[["rotatey(180deg)",
	  "ROTATEY(180DEG)",
	  "rOtAtEy(180DeG)"],
	 -1, 0, 0, 0,  0, 1, 0, 0,  0, 0, -1, 0,  0, 0, 0, 1],
	[["rotatez(180deg)",
	  "ROTATEZ(180DEG)",
	  "rOtAtEz(180DeG)"],
	 -1, 0, 0, 0,  0, -1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1],
	// FIXME: The spec doesn't actually define skew(), so I figured it out from
	// implementations. https://www.w3.org/Bugs/Public/show_bug.cgi?id=15537
	// (Why is skew defined in the 3D transforms spec but not 2D?)
	[["skew(45deg, 45deg)",
	  "SKEW(45DEG, 45DEG)",
	  "sKeW(45dEg, 45DeG)"],
	 1, 1, 0, 0,  1, 1, 0, 0,  0, 0, 1, 0,  0, 0, 0, 1],
	// FIXME: The spec has a bug in its definition of perspective().
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15538
	[["perspective(400px)",
	  "PERSPECTIVE(400PX)",
	  "pErSpEcTiVe(400Px)"],
	 1, 0, 0, 0,  0, 1, 0, 0,  0, 0, 1, -1/400,  0, 0, 0, 1],
].forEach(function(arr) {
	arr[0].forEach(function(transform, i) {
		var transformKeyword = {0: "TRANSFORM", 1: "tRAnSFoRM", 2: "transform"}[i%3];
		test(function() {
			div.style[prop.replace("transform", transformKeyword)] = transform;
			testTransformParsing(arr.slice(1));
		}, "Computed value for " + transformKeyword + ": " + transform + " set via CSSOM");
	});
});
div.removeAttribute("style");

/*
// FIXME: The spec doesn't match browsers for serialization of the transform
// property when it's unset or "none".
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15471
//test(function() {
//	testTransformParsing([1, 0, 0, 1, 0, 0]);
//}, "Computed value for transform with no style attribute");
test(function() {
	// Not really a transform test, just included for completeness.  It can
	// serve as something of a sanity check.
	testTransformedBoundaryAsserts(0, divWidth, divHeight, 0);
}, "Boundaries with no style attribute");

testTransform("none", [1, 0, 0, 1, 0, 0]);

// Test style="transform: matrix(*)" (4^6 = 4096 permutations, but we only run
// every 13th to avoid creating excessive numbers of tests)
(function(){
var matrixValues = [-1, 0, 1, 1.72];
var i = 0;
matrixValues.forEach(function(a) {
matrixValues.forEach(function(b) {
matrixValues.forEach(function(c) {
matrixValues.forEach(function(d) {
matrixValues.forEach(function(e) {
matrixValues.forEach(function(f) {
	if (i % 13 == 0) {
		testTransform(
			"matrix(" + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + ")",
			[a, b, c, d, e, f]
		);
	}
	i++;
	i %= 13;
});
});
});
});
});
});
})();

// Test translate()/translateX()/translateY()
percentagesAndLengths.forEach(function(tx) {
	testTransform(
		"translateX(" + tx + ")",
		[1, 0, 0, 1, convertToPx(tx, divWidth), 0]
	);
	// tx is poorly named, since it's used for y here.
	testTransform(
		"translateY(" + tx + ")",
		[1, 0, 0, 1, 0, convertToPx(tx, divHeight)]
	);
	testTransform(
		"translate(" + tx + ")",
		[1, 0, 0, 1, convertToPx(tx, divWidth), 0]
	);

	percentagesAndLengths.forEach(function(ty) {
		testTransform(
			"translate(" + tx + ", " + ty + ")",
			[1, 0, 0, 1, convertToPx(tx, divWidth), convertToPx(ty, divHeight)]
		);
	});
});

// Test scale()/scaleX()/scaleY()
(function(){
var scales = [-2, -1, -0.12, 0, 0.12, 1, 2];
scales.forEach(function(sx) {
	testTransform(
		"scaleX(" + sx + ")",
		[sx, 0, 0, 1, 0, 0]
	);
	// sx is poorly named, since it's used for y here, then for both x and y.
	testTransform(
		"scaleY(" + sx + ")",
		[1, 0, 0, sx, 0, 0]
	);
	testTransform(
		"scale(" + sx + ")",
		[sx, 0, 0, sx, 0, 0]
	);

	scales.forEach(function(sy) {
		testTransform(
			"scale(" + sx + ", " + sy + ")",
			[sx, 0, 0, sy, 0, 0]
		);
	});
});
})();

// Test rotate()
[
	"-7deg", "0deg", "22.5deg", "45deg", "86.451deg", "90deg", "180deg",
	"270deg", "452deg",
	"-1rad", "0rad", "1rad", "6.28rad",
	"0.721turn", "256grad",
].forEach(function(angle) {
	var rads = convertToRad(angle);
	testTransform(
		"rotate(" + angle + ")",
		[Math.cos(rads), Math.sin(rads), -Math.sin(rads), Math.cos(rads),
		0, 0]
	);
});

// Test skewX()/skewY()
//
// Do not test values close to 90 degrees, because this will cause coordinates
// to get large.  The maximum values for coordinates are (of course) not
// defined, and even if they were, the result would be extremely sensitive to
// rounding error.
[
	"-80deg", "-45deg", "-32.6deg", "-0.05deg", "0deg", "0.05deg", "32.6deg",
	"45deg", "80deg", "300deg",
	"-0.3rad", "0rad", "0.3rad", "2.9rad",
	"0.921turn", "22grad"
].forEach(function(angle) {
	testTransform(
		"skewX(" + angle + ")",
		[1, 0, Math.tan(convertToRad(angle)), 1, 0, 0]
	);
	testTransform(
		"skewY(" + angle + ")",
		[1, Math.tan(convertToRad(angle)), 0, 1, 0, 0]
	);
});

// Test multiple transformations
(function(){
var transforms = [
	["matrix(4, -7, 2.3, -3.8, 6, 6)", 4, -7, 2.3, -3.8, 6, 6],
	["translate(0.23in, -17pt)",
		1, 0, 0, 1, convertToPx("0.23in"), convertToPx("-17pt")],
	["scale(1.3, -5.6)", 1.3, 0, 0, -5.6, 0, 0],
	["rotate(0.759rad)", Math.cos(0.759), Math.sin(0.759),
		-Math.sin(0.759), Math.cos(0.759), 0, 0],
	["skewX(-0.221rad)", 1, 0, Math.tan(-0.221), 1, 0, 0],
];
transforms.forEach(function(trans1) {
	testTransform(trans1[0], trans1.slice(1));

	transforms.forEach(function(trans2) {
		var mx = mxmul32(trans1.slice(1), trans2.slice(1));

		// First put both transforms on the test div
		testTransform(trans1[0] + " " + trans2[0], mx);

		// Now put the first on its grandparent, and the second on its parent.
		// No need to test parsing.
		testTransformedBoundary([trans1[0], trans2[0], "none"], mx);

		transforms.forEach(function(trans3) {
			var mx = mxmul32(mxmul32(trans1.slice(1), trans2.slice(1)), trans3.slice(1));
			testTransform(trans1[0] + " " + trans2[0] + " " + trans3[0], mx);
			testTransformedBoundary([trans1[0], trans2[0], trans3[0]], mx);
		});
	});
});
})();


// Test transform-origin with one argument
[
	["none", "50%", "50%"],
	["NONE", "50%", "50%"],
	["nOnE", "50%", "50%"],
	["quasit", "50%", "50%"],
	["top", "50%", "0%"],
	["TOP", "50%", "0%"],
	["tOp", "50%", "0%"],
	["right", "100%", "50%"],
	["RIGHT", "100%", "50%"],
	["rIgHt", "100%", "50%"],
	["bottom", "50%", "100%"],
	["BOTTOM", "50%", "100%"],
	["bOtToM", "50%", "100%"],
	["left", "0%", "50%"],
	["LEFT", "0%", "50%"],
	["lEfT", "0%", "50%"],
	["center", "50%", "50%"],
	["CENTER", "50%", "50%"],
	["cEnTeR", "50%", "50%"],
	["37%", "37%", "50%"],
	["117%", "117%", "50%"],
	["41.2px", "41.2px", "50%"],
	["-31.8px", "-31.8px", "50%"],
].forEach(function(arr) {
	testTransformOrigin(arr[0], arr[1], arr[2]);
});

// Test transform-origin with two arguments.
["left", "center", "right"].concat(percentagesAndLengths).forEach(function(arg1) {
	["top", "center", "bottom"].concat(percentagesAndLengths).forEach(function(arg2) {
		testTransformOrigin(arg1 + " " + arg2, arg1, arg2);
	});
});

// FIXME: Three- and four-value variants are not generally implemented; see
// revision history for tests
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15432
*/

[].forEach.call(document.querySelectorAll("style"), function(style) {style.disabled = true});
</script>
