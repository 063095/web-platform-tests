<!doctype html>
<title>CSS 2D Transforms tests</title>
<link rel=author title="Aryeh Gregor" href="ayg@aryeh.name">
<script src=http://w3c-test.org/resources/testharness.js></script>
<script src=http://w3c-test.org/resources/testharnessreport.js></script>
<style>
/* Everything we care about is relative to the border box: in particular,
 * percentages are all computed relative to the border box, and
 * getBoundingClientRect() is relative to the border box.  The default
 * transform-origin is the center of the border box.
 *
 * Our setup is the test div is nested in two other divs nested in the body.
 * The test div has width 80px and height 30px, then 5px each of padding,
 * border, and margin.  (This is to catch UAs that compute things relative to
 * the content, padding, or margin boxes instead of border.)  Thus its border
 * box is 100px wide and 50px tall, and its margin box is 110px by 60px.
 *
 * The test div's parent has a content area large enough to contain its child,
 * and then five pixels of padding.  The same holds for the test div's
 * grandparent.  Finally, the body has a content area large enough to hold its
 * div child, and -15px of margin so that the test div's border box lines up
 * with the top left of the viewport (makes calculations easier).
 *
 * In this way, the border boxes of the test div and its parent and grandparent
 * all have the same center, so the transform-origin is the same with no extra
 * work.  However, they have different sizes, so percentages need to be
 * computed differently. */
body {
	margin: -15px;
	width: 130px;
	height: 80px;
}
body > div {
	width: 120px;
	height: 70px;
	padding: 5px;
	background: orange;
}
body > div > div {
	width: 110px;
	height: 60px;
	padding: 5px;
	background: yellow;
}
body, div {
	position: relative;
}
#test {
	position: static;
	height: 30px;
	width: 80px;
	padding: 5px;
	border: 5px solid black;
	margin: 5px;
	background: blue;
}
#log { display: none }
</style>
<!-- Extra styles we switch between.  They should all look the same, so which
one we use shouldn't affect results.  To ensure that they look the same even
when transforms are applied to different divs, they're designed to not move the
border box of any of the three nested divs. -->
<style class=switch></style>
<style class=switch>
div { float: left }
</style>
<style class=switch>
div { float: right }
</style>
<style class=switch>
div { float: right }
body { width: 180px; margin-left: -65px }
</style>
<style class=switch>
#test { position: absolute }
</style>
<style class=switch>
body > div > div { border-right: 10px solid transparent; width: 100px }
#test { position: absolute; right: -5px }
</style>
<style class=switch>
body > div > div { padding-left: 10px; width: 105px }
#test { position: relative; left: -5px }
</style>
<style class=switch>
#test { display: inline-block }
</style>
<style class=switch>
#test { display: table }
</style>
<div><div><div id=test></div></div></div>
<div id=log></div>
<script>
// TODO: Test images, CSSMatrix, interaction with SVG, overflow, creation of
// stacking context/containing block, fixed backgrounds, specificity of SVG
// transform attribute, inheritance (computed values)
//
// Not for now: transitions, animations
var div = document.querySelector("#test");
var divWidth = 100, divHeight = 50;
// Arbitrarily chosen epsilon that makes browsers mostly pass with some extra
// breathing room, since the specs don't define rounding.
var epsilon = 1.5;
// Account for prefixing so that I can check whether browsers actually follow
// the spec.  Obviously, in any final version of the test, only the unprefixed
// property will be tested.
var prop = "transform" in div.style ? "transform"
	: "msTransform" in div.style ? "msTransform"
	: "MozTransform" in div.style ? "MozTransform"
	: "webkitTransform" in div.style ? "webkitTransform"
	: "OTransform" in div.style ? "OTransform"
	: undefined;
var hyphenatedProp = {
	transform: "transform",
	msTransform: "-ms-transform",
	MozTransform: "-moz-transform",
	webkitTransform: "-webkit-transform",
	OTransform: "-o-transform",
}[prop];
var percentagesAndLengths = [
	".0",
	"-53.7px", "-1px", "0.0px", "0.12px", "1px", "53.7px",
	"-50%", "0%", "0.12%",
	"1em", "1ex", "1in", "1cm", "1mm", "1pt", "1pc"];
var emPixels = parseFloat(getComputedStyle(div).fontSize);
div.style.fontSize = "1ex";
var exPixels = parseFloat(getComputedStyle(div).fontSize);
div.removeAttribute("style");

var switchStyles = document.querySelectorAll("style.switch");
[].forEach.call(switchStyles, function(style) { style.disabled = true });

/**
 * Accepts a string that's a CSS length or percentage, and returns a number of
 * pixels (not a string), or null if parsing fails.  For percentages to be
 * accepted, percentRef must not be undefined.
 */
function convertToPx(input, percentRef) {
	var match = /^([-+]?[0-9]+|[-+]?[0-9]*\.[0-9]+)(em|ex|in|cm|mm|pt|pc|px|%)?$/.exec(input);
	if (!match) {
		return null;
	}
	var amount = Number(match[1]);
	var unit = match[2];
	if (amount == 0) {
		return 0;
	}
	if (!unit) {
		return null;
	}
	if (unit == "%" && percentRef === undefined) {
		return null;
	}
	return amount * {
		em: emPixels,
		ex: exPixels,
		in: 72/0.75,
		cm: (1/2.54)*72/0.75,
		mm: (1/25.4)*72/0.75,
		pt: 1/0.75,
		pc: 12/0.75,
		px: 1,
		"%": percentRef/100,
	}[unit];
}

/**
 * Accepts a string that's a CSS angle, and returns a number of radians (not a
 * string), or null if parsing fails.
 */
function convertToRad(input) {
	var match = /^([-+]?[0-9]+|[-+]?[0-9]*\.[0-9]+)(deg|grad|rad|turn)$/.exec(input);
	if (!match) {
		return null;
	}
	var amount = Number(match[1]);
	var unit = match[2];
	return amount * {
		deg: Math.PI/180,
		grad: Math.PI/200,
		rad: 1,
		turn: 2*Math.PI,
	}[unit];
}

/**
 * Multiplies two 3x2 matrices.
 */
function mxmul(A, B) {
	return [
		A[0]*B[0] + A[2]*B[1],
		A[1]*B[0] + A[3]*B[1],
		A[0]*B[2] + A[2]*B[3],
		A[1]*B[2] + A[3]*B[3],
		A[0]*B[4] + A[2]*B[5] + A[4],
		A[1]*B[4] + A[3]*B[5] + A[5]
	];
}

/**
 * Returns true or false every time it's called.  It more or less alternates,
 * but actually has a period of 17, so it won't repeat with the same period as
 * other cyclic things (these are quite repetitive tests).
 */
function getUseCssom() {
	if (getUseCssom.counter === undefined) {
		getUseCssom.counter = 0;
	}
	getUseCssom.counter++;
	getUseCssom.counter %= 17;
	return Boolean(getUseCssom.counter % 2);
}

/**
 * Tests that style="transform: value" results in transformation by the matrix
 * [a, b, c, d, e, f].  Checks both the computed value and bounding box.
 */
function testTransform(value, a, b, c, d, e, f) {
	// FIXME: The spec doesn't match browsers for serialization of the
	// transform property when it's unset or "none".
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15471
	if (value != "none") {
		var useCssom = getUseCssom();
		test(function() {
			if (useCssom) {
				div.removeAttribute("style");
				div.style[prop] = value;
			} else {
				div.setAttribute("style", hyphenatedProp + ": " + value);
			}
			testTransformParsing(a, b, c, d, e, f);
		}, "Computed value for transform: " + value
		+ " set via " + (useCssom ? "CSSOM" : "setAttribute()"));
	}
	testTransformedBoundary(value, a, b, c, d, e, f);
}

/**
 * Tests that div's computed style for transform is "matrix(a, b, c, d, e, f)".
 */
function testTransformParsing(a, b, c, d, e, f) {
	// FIXME: We allow px optionally in the last two entries because Gecko
	// adds it while other engines don't, and the spec is unclear about
	// which behavior is correct:
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15431
	var computed = getComputedStyle(div)[prop];
	var re = /^matrix\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+?)(?:px)?, ([^,]+?)(?:px)?\)$/;
	assert_regexp_match(computed, re, "computed value has unexpected form");
	var match = re.exec(computed);
	assert_approx_equals(Number(match[1]), a, epsilon, "getComputedStyle first matrix component");
	assert_approx_equals(Number(match[2]), b, epsilon, "getComputedStyle second matrix component");
	assert_approx_equals(Number(match[3]), c, epsilon, "getComputedStyle third matrix component");
	assert_approx_equals(Number(match[4]), d, epsilon, "getComputedStyle fourth matrix component");
	assert_approx_equals(Number(match[5]), e, epsilon, "getComputedStyle fifth matrix component");
	assert_approx_equals(Number(match[6]), f, epsilon, "getComputedStyle sixth matrix component");
}

/**
 * Tests that
 *   style="transform: transformValue; transform-origin: transformOriginValue"
 * results in the boundary box that you'd get from transforming with a matrix
 * of [a, b, c, d, e, f] around an offset of [xOffset, yOffset].
 * transformOriginValue defaults to "50% 50%", xOffset to divWidth/2, yOffset
 * to divHeight/2.
 *
 * transformValue can also be an array of three values.  If it is, they're used
 * for the test div's grandparent, its parent, and the test div itself,
 * respectively.  a, b, c, d, e, f should then be the entries of the matrix of
 * all three transforms multiplied together.
 */
function testTransformedBoundary(transformValue, a, b, c, d, e, f,
                                 transformOriginValue, xOffset, yOffset) {
	// Don't test singular matrices for now.  IE fails some of them, which
	// might be due to getBoundingClientRect() instead of transforms.
	if (a*d - b*c === 0) {
		return;
	}

	if (transformOriginValue === undefined) {
		transformOriginValue = "50% 50%";
	}
	if (xOffset === undefined) {
		xOffset = divWidth/2;
	}
	if (yOffset === undefined) {
		yOffset = divHeight/2;
	}

	// Compute the expected bounding box by applying the given matrix to the
	// vertices of the test div's border box.
	var originalPoints = [[0, 0], [0, divHeight], [divWidth, 0], [divWidth, divHeight]];
	var expectedTop, expectedRight, expectedBottom, expectedLeft;
	for (var i = 0; i < originalPoints.length; i++) {
		var newX = a*(originalPoints[i][0]-xOffset) + c*(originalPoints[i][1]-yOffset) + e + xOffset;
		var newY = b*(originalPoints[i][0]-xOffset) + d*(originalPoints[i][1]-yOffset) + f + yOffset;
		if (expectedTop === undefined || newY < expectedTop) {
			expectedTop = newY;
		}
		if (expectedRight === undefined || newX > expectedRight) {
			expectedRight = newX;
		}
		if (expectedBottom === undefined || newY > expectedBottom) {
			expectedBottom = newY;
		}
		if (expectedLeft === undefined || newX < expectedLeft) {
			expectedLeft = newX;
		}
	}

	// Pick a different <style class=switch> for each test; they shouldn't
	// affect results, so it's fine to just alternate.  We cycle through using
	// a reasonably large prime number (19) so that when the tests are
	// repetitive, we're unlikely to keep hitting the same styles for the same
	// sort of test.
	if (testTransformedBoundary.switchStyleIdx === undefined) {
		testTransformedBoundary.switchStyleIdx = switchStyles.length - 1;
	}
	switchStyles[testTransformedBoundary.switchStyleIdx % switchStyles.length].disabled = true;
	testTransformedBoundary.switchStyleIdx++;
	testTransformedBoundary.switchStyleIdx %= 19;
	switchStyles[testTransformedBoundary.switchStyleIdx % switchStyles.length].disabled = false;

	if (testTransformedBoundary.cssomIdx === undefined) {
		testTransformedBoundary.cssomIdx = 0;
	}

	var useCssom = getUseCssom();
	if (typeof transformValue == "string") {
		test(function() {
			if (useCssom) {
				div.removeAttribute("style");
				div.style[prop] = transformValue;
				div.style[prop + "Origin"] = transformOriginValue;
			} else {
				div.setAttribute("style", hyphenatedProp + ": " + transformValue + "; "
					+ hyphenatedProp + "-origin: " + transformOriginValue);
			}
			testTransformedBoundaryAsserts(expectedTop, expectedRight, expectedBottom, expectedLeft);
		}, "Boundaries with \"transform: " + transformValue + "; "
		+ "transform-origin: " + transformOriginValue + "\" "
		+ "set via " + (useCssom ? "CSSOM" : "setAttribute()") + "; "
		+ "switch style " + (testTransformedBoundary.switchStyleIdx % switchStyles.length));
	} else {
		test(function() {
			if (useCssom) {
				div.parentNode.parentNode.style[prop] = transformValue[0];
				div.parentNode.style[prop] = transformValue[1];
				div.removeAttribute("style");
				div.style[prop] = transformValue[2];
				div.style[prop + "Origin"] = transformOriginValue;
			} else {
				div.parentNode.parentNode.setAttribute("style",
					hyphenatedProp + ": " + transformValue[0]);
				div.parentNode.setAttribute("style",
					hyphenatedProp + ": " + transformValue[1]);
				div.setAttribute("style",
					hyphenatedProp + ": " + transformValue[2] + "; "
					+ hyphenatedProp + "-origin: " + transformOriginValue);
			}
			testTransformedBoundaryAsserts(expectedTop, expectedRight, expectedBottom, expectedLeft);
		}, "Boundaries with \"transform: " + transformValue[0] + "\" on test div's grandparent, "
		+ "\"transform: " + transformValue[1] + "\" on its parent, "
		+ "\"transform: " + transformValue[2] + "; "
		+ "transform-origin: " + transformOriginValue + "\" on test div, "
		+ "set via " + (useCssom ? "CSSOM" : "setAttribute()") + "; "
		+ "switch style " + (testTransformedBoundary.switchStyleIdx % switchStyles.length));

		div.parentNode.removeAttribute("style");
		div.parentNode.parentNode.removeAttribute("style");
	}
}

function testTransformedBoundaryAsserts(expectedTop, expectedRight, expectedBottom, expectedLeft) {
	// FIXME: We assume getBoundingClientRect() returns the rectangle
	// that contains the transformed box, not the untransformed box.
	// This is not actually specified anywhere:
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15430
	var rect = div.getBoundingClientRect();
	var msg = " (actual " + rect.top.toFixed(3) + ", "
		+ rect.right.toFixed(3) + ", "
		+ rect.bottom.toFixed(3) + ", "
		+ rect.left.toFixed(3) + "; "
		+ "expected " + expectedTop.toFixed(3) + ", "
		+ expectedRight.toFixed(3) + ", "
		+ expectedBottom.toFixed(3) + ", "
		+ expectedLeft.toFixed(3) + ")";
	assert_approx_equals(rect.top, expectedTop, epsilon, "top" + msg);
	assert_approx_equals(rect.right, expectedRight, epsilon, "right" + msg);
	assert_approx_equals(rect.bottom, expectedBottom, epsilon, "bottom" + msg);
	assert_approx_equals(rect.left, expectedLeft, epsilon, "left" + msg);
	assert_approx_equals(rect.width, expectedRight - expectedLeft, epsilon, "width" + msg);
	assert_approx_equals(rect.height, expectedBottom - expectedTop, epsilon, "height" + msg);
}

// Test case-sensitivity
[
	// FIXME: The spec doesn't match browsers for serialization of the
	// transform property when it's unset or "none".
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15471
	// [["none", "NONE", "nOnE"], 1, 0, 0, 1, 0, 0],
	[["matrix(1,2,3,4,5,6)", "MATRIX(1,2,3,4,5,6)", "mAtRiX(1,2,3,4,5,6)"], 1, 2, 3, 4, 5, 6],
	[["translate(1px)", "TRANSLATE(1PX)", "tRaNsLaTe(1Px)"], 1, 0, 0, 1, 1, 0],
	[["translatex(1pt)", "TRANSLATEX(1PT)", "tRaNsLaTeX(1pT)"], 1, 0, 0, 1, 0.75, 0],
	[["translatey(1in)", "TRANSLATEY(1IN)", "tRaNsLaTeY(1iN)"], 1, 0, 0, 1, 0, 96],
	[["scale(2)", "SCALE(2)", "sCaLe(2)"], 2, 0, 0, 2, 0, 0],
	[["scalex(2)", "SCALEX(2)", "sCaLeX(2)"], 2, 0, 0, 1, 0, 0],
	[["scaley(2)", "SCALEY(2)", "sCaLeY(2)"], 1, 0, 0, 2, 0, 0],
	// Nothing much uses angle units, so I'll test the case-insensitivity of
	// those while I'm here.
	[["rotate(90deg)", "ROTATE(90DEG)", "rOtAtE(90dEg)",
	  "rotate(100grad)", "ROTATE(100GRAD)", "rOtAtE(100gRaD)",
	  "rotate(0.7854rad)", "ROTATE(0.7854RAD)", "rOtAtE(0.7854rAd)",
	  "rotate(0.25turn)", "ROTATE(0.25TUN)", "rOtAtE(0.25tUrN)"], 0, 1, -1, 0, 0, 0],
	[["skewx(45deg)", "SKEWX(45DEG)", "sKeWx(45DeG)"], 1, 0, 1, 1, 0, 0],
	[["skewy(45deg)", "SKEWY(45DEG)", "sKeWy(45DeG)"], 1, 1, 0, 1, 0, 0],
].forEach(function(arr) {
	arr[0].forEach(function(transform, i) {
		var transformKeyword = {0: "TRANSFORM", 1: "tRAnSFoRM", 2: "transform"}[i%3];
		test(function() {
			div.style[prop.replace("transform", transformKeyword)] = transform;
			testTransformParsing(arr[1], arr[2], arr[3], arr[4], arr[5], arr[6]);
		}, "Computed value for " + transformKeyword + ": " + transform + " set via CSSOM");
	});
});
div.removeAttribute("style");

// FIXME: The spec doesn't match browsers for serialization of the transform
// property when it's unset or "none".
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15471
//test(function() {
//	testTransformParsing(1, 0, 0, 1, 0, 0);
//}, "Computed value for transform with no style attribute");
test(function() {
	// Not really a transform test, just included for completeness.  It can
	// serve as something of a sanity check.
	testTransformedBoundaryAsserts(0, divWidth, divHeight, 0);
}, "Boundaries with no style attribute");

testTransform("none", 1, 0, 0, 1, 0, 0);

// Test style="transform: matrix(*)" (4^6 = 4096 permutations, but we only run
// every 13th to avoid creating excessive numbers of tests)
(function(){
var matrixValues = [-1, 0, 1, 1.72];
var i = 0;
matrixValues.forEach(function(a) {
matrixValues.forEach(function(b) {
matrixValues.forEach(function(c) {
matrixValues.forEach(function(d) {
matrixValues.forEach(function(e) {
matrixValues.forEach(function(f) {
	if (i % 13 == 0) {
		testTransform(
			"matrix(" + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + ")",
			a, b, c, d, e, f
		);
	}
	i++;
	i %= 13;
});
});
});
});
});
});
})();

// Test translate()/translateX()/translateY()
percentagesAndLengths.forEach(function(tx) {
	testTransform(
		"translateX(" + tx + ")",
		1, 0, 0, 1, convertToPx(tx, divWidth), 0
	);
	// tx is poorly named, since it's used for y here.
	testTransform(
		"translateY(" + tx + ")",
		1, 0, 0, 1, 0, convertToPx(tx, divHeight)
	);
	testTransform(
		"translate(" + tx + ")",
		1, 0, 0, 1, convertToPx(tx, divWidth), 0
	);

	percentagesAndLengths.forEach(function(ty) {
		testTransform(
			"translate(" + tx + ", " + ty + ")",
			1, 0, 0, 1, convertToPx(tx, divWidth), convertToPx(ty, divHeight)
		);
	});
});

// Test scale()/scaleX()/scaleY()
(function(){
var scales = [-2, -1, -0.12, 0, 0.12, 1, 2];
scales.forEach(function(sx) {
	testTransform(
		"scaleX(" + sx + ")",
		sx, 0, 0, 1, 0, 0
	);
	// sx is poorly named, since it's used for y here, then for both x and y.
	testTransform(
		"scaleY(" + sx + ")",
		1, 0, 0, sx, 0, 0
	);
	testTransform(
		"scale(" + sx + ")",
		sx, 0, 0, sx, 0, 0
	);

	scales.forEach(function(sy) {
		testTransform(
			"scale(" + sx + ", " + sy + ")",
			sx, 0, 0, sy, 0, 0
		);
	});
});
})();

// Test rotate()
[
	"-7deg", "0deg", "22.5deg", "45deg", "86.451deg", "90deg", "180deg",
	"270deg", "452deg",
	"-1rad", "0rad", "1rad", "6.28rad",
	"0.721turn", "256grad",
].forEach(function(angle) {
	var rads = convertToRad(angle);
	testTransform(
		"rotate(" + angle + ")",
		Math.cos(rads), Math.sin(rads), -Math.sin(rads), Math.cos(rads),
		0, 0
	);
});

// Test skewX()/skewY()
//
// Do not test values close to 90 degrees, because this will cause coordinates
// to get large.  The maximum values for coordinates are (of course) not
// defined, and even if they were, the result would be extremely sensitive to
// rounding error.
[
	"-80deg", "-45deg", "-32.6deg", "-0.05deg", "0deg", "0.05deg", "32.6deg",
	"45deg", "80deg", "300deg",
	"-0.3rad", "0rad", "0.3rad", "2.9rad",
	"0.921turn", "22grad"
].forEach(function(angle) {
	testTransform(
		"skewX(" + angle + ")",
		1, 0, Math.tan(convertToRad(angle)), 1, 0, 0
	);
	testTransform(
		"skewY(" + angle + ")",
		1, Math.tan(convertToRad(angle)), 0, 1, 0, 0
	);
});

// Test multiple transformations
(function(){
var transforms = [
	["matrix(4, -7, 2.3, -3.8, 6, 6)", 4, -7, 2.3, -3.8, 6, 6],
	["translate(0.23in, -17pt)",
		1, 0, 0, 1, convertToPx("0.23in"), convertToPx("-17pt")],
	["scale(1.3, -5.6)", 1.3, 0, 0, -5.6, 0, 0],
	["rotate(0.759rad)", Math.cos(0.759), Math.sin(0.759),
		-Math.sin(0.759), Math.cos(0.759), 0, 0],
	["skewX(-0.221rad)", 1, 0, Math.tan(-0.221), 1, 0, 0],
];
transforms.forEach(function(trans1) {
	testTransform(trans1[0], trans1[1], trans1[2],
		trans1[3], trans1[4], trans1[5], trans1[6]);

	transforms.forEach(function(trans2) {
		var mx = mxmul(trans1.slice(1), trans2.slice(1));

		// First put both transforms on the test div
		testTransform(trans1[0] + " " + trans2[0],
			mx[0], mx[1], mx[2], mx[3], mx[4], mx[5]);

		// Now put the first on its grandparent, and the second on its parent.
		// No need to test parsing.
		testTransformedBoundary([trans1[0], trans2[0], "none"],
			mx[0], mx[1], mx[2], mx[3], mx[4], mx[5]);

		transforms.forEach(function(trans3) {
			var mx = mxmul(mxmul(trans1.slice(1), trans2.slice(1)), trans3.slice(1));
			testTransform(trans1[0] + " " + trans2[0] + " " + trans3[0],
				mx[0], mx[1], mx[2], mx[3], mx[4], mx[5]);
			testTransformedBoundary([trans1[0], trans2[0], trans3[0]],
				mx[0], mx[1], mx[2], mx[3], mx[4], mx[5]);
		});
	});
});
})();


/**
 * Test that "transform-origin: value" acts like the origin is at
 * (expectedHoriz, expectedVert), where the latter two parameters can be
 * keywords, percentages, or lengths.  Tests both that the computed value is
 * correct, and that the boundary box is as expected for a 45-degree rotation.
 */
function testTransformOrigin(value, expectedHoriz, expectedVert) {
	if (expectedHoriz == "left") {
		expectedHoriz = "0%";
	} else if (expectedHoriz == "center") {
		expectedHoriz = "50%";
	} else if (expectedHoriz == "right") {
		expectedHoriz = "100%";
	}
	if (expectedVert == "top") {
		expectedVert = "0%";
	} else if (expectedVert == "center") {
		expectedVert = "50%";
	} else if (expectedVert == "bottom") {
		expectedVert = "100%";
	}
	// FIXME: Nothing defines resolved values here.  I picked the behavior of
	// all non-Gecko engines, which is also the behavior Gecko for transforms
	// other than "none": https://www.w3.org/Bugs/Public/show_bug.cgi?id=15433
	expectedHoriz = convertToPx(expectedHoriz, divWidth);
	expectedVert = convertToPx(expectedVert, divHeight);

	if (testTransformOrigin.counter === undefined) {
		testTransformOrigin.counter = 0;
	}
	// The transform doesn't matter here, so set it to one of several
	// possibilities arbitrarily (this actually catches a Gecko bug!)
	var transformValue = {
		0: "none",
		1: "matrix(7, 0, -1, 13, 0, 0)",
		2: "translate(4em, -15px)",
		3: "scale(1.2, 1)",
		4: "rotate(43deg)",
	}[testTransformOrigin.counter % 5];
	testTransformOrigin.counter++;
	div.removeAttribute("style");

	test(function() {
		div.style[prop] = transformValue;
		div.style[prop + "Origin"] = value;
		testTransformOriginParsing(expectedHoriz, expectedVert);
	}, "Computed value for transform-origin with transform: " + transformValue + "; transform-origin: " + value + " set via CSSOM");
	test(function() {
		div.setAttribute("style", hyphenatedProp + ": " + transformValue
			+ "; " + hyphenatedProp + "-origin:" + value);
		testTransformOriginParsing(expectedHoriz, expectedVert);
	}, "Computed value for transform-origin with transform: " + transformValue + "; transform-origin: " + value + " set via setAttribute()");

	// Test with a 45-degree rotation, since the effect of changing the origin
	// will be easy to understand.
	testTransformedBoundary(
		// Transform
		"rotate(45deg)",
		// Matrix entries
		Math.cos(Math.PI/4), Math.sin(Math.PI/4),
		-Math.sin(Math.PI/4), Math.cos(Math.PI/4),
		0, 0,
		// Origin
		value, expectedHoriz, expectedVert
	);
}

/**
 * Tests that style="transform-origin: value" results in
 * getComputedStyle().transformOrigin being expectedHoriz + "px " + expectedVert + "px".
 */
function testTransformOriginParsing(expectedHoriz, expectedVert) {
	var actual = getComputedStyle(div)[prop + "Origin"];
	var re = /^([^ ]+)px ([^ ]+)px$/;
	assert_regexp_match(actual, re, "Computed value has unexpected form");
	var match = re.exec(actual);

	assert_approx_equals(Number(match[1]), expectedHoriz,
		epsilon, "Value of horizontal part (actual: "
			 + actual + ", expected " + expectedHoriz + "px " + expectedVert + "px)");

	assert_approx_equals(Number(match[2]), expectedVert,
		epsilon, "Value of vertical part (actual: "
			 + actual + ", expected " + expectedHoriz + "px " + expectedVert + "px)");
}

// Test transform-origin with one argument
[
	["none", "50%", "50%"],
	["NONE", "50%", "50%"],
	["nOnE", "50%", "50%"],
	["quasit", "50%", "50%"],
	["top", "50%", "0%"],
	["TOP", "50%", "0%"],
	["tOp", "50%", "0%"],
	["right", "100%", "50%"],
	["RIGHT", "100%", "50%"],
	["rIgHt", "100%", "50%"],
	["bottom", "50%", "100%"],
	["BOTTOM", "50%", "100%"],
	["bOtToM", "50%", "100%"],
	["left", "0%", "50%"],
	["LEFT", "0%", "50%"],
	["lEfT", "0%", "50%"],
	["center", "50%", "50%"],
	["CENTER", "50%", "50%"],
	["cEnTeR", "50%", "50%"],
	["37%", "37%", "50%"],
	["117%", "117%", "50%"],
	["41.2px", "41.2px", "50%"],
	["-31.8px", "-31.8px", "50%"],
].forEach(function(arr) {
	testTransformOrigin(arr[0], arr[1], arr[2]);
});

// Test transform-origin with two arguments.
["left", "center", "right"].concat(percentagesAndLengths).forEach(function(arg1) {
	["top", "center", "bottom"].concat(percentagesAndLengths).forEach(function(arg2) {
		testTransformOrigin(arg1 + " " + arg2, arg1, arg2);
	});
});

// FIXME: Three- and four-value variants are not generally implemented; see
// revision history for tests
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15432

[].forEach.call(document.querySelectorAll("style"), function(style) {style.disabled = true});
</script>
