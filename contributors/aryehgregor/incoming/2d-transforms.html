<!doctype html>
<title>CSS 2D Transforms tests</title>
<link rel=author title="Aryeh Gregor" href="ayg@aryeh.name">
<script src=http://w3c-test.org/resources/testharness.js></script>
<script src=http://w3c-test.org/resources/testharnessreport.js></script>
<style>
/* Everything we care about is relative to the border box: in particular,
 * percentages are all computed relative to the border box, and
 * getBoundingClientRect() is relative to the border box.  Thus for our
 * purposes, the div is 100px wide and 50px tall, with its upper left corner at
 * the origin. */
body {
	margin: -5px;
	width: 110px;
	position: relative;
}
#test {
	height: 30px;
	width: 80px;
	padding: 5px;
	border: 5px solid black;
	margin: 5px;
	background: blue;
}
</style>
<!-- Extra styles we switch between.  They should all look the same, so which
one we use shouldn't affect results. -->
<style class=switch></style>
<style class=switch>
#test { float: left }
</style>
<style class=switch>
#test { float: right }
</style>
<style class=switch>
#test { float: right }
body { width: 160px; margin-left: -55px }
</style>
<style class=switch>
#test { position: absolute }
</style>
<style class=switch>
#test { position: absolute; right: 50px }
body { width: 160px }
</style>
<style class=switch>
#test { position: relative; left: 50px }
body { margin-left: -55px }
</style>
<style class=switch>
#test { display: inline-block }
</style>
<style class=switch>
#test { display: table }
</style>
<div id=test></div>
<div id=log></div>
<script>
// TODO: Test images, CSSMatrix, interaction with SVG, nested transformations,
// overflow, creation of stacking context/containing block, fixed backgrounds,
// specificity of SVG transform attribute, inheritance (computed values)
//
// Not for now: transitions, animations
var div = document.querySelector("#test");
var divWidth = 100, divHeight = 50;
// Arbitrarily chosen epsilon that makes browsers mostly pass with some extra
// breathing room, since the specs don't define rounding.
var epsilon = 1.5;
// Account for prefixing so that I can check whether browsers actually follow
// the spec.  Obviously, in any final version of the test, only the unprefixed
// property will be tested.
var prop = "transform" in div.style ? "transform"
	: "msTransform" in div.style ? "msTransform"
	: "MozTransform" in div.style ? "MozTransform"
	: "webkitTransform" in div.style ? "webkitTransform"
	: "OTransform" in div.style ? "OTransform"
	: undefined;
var hyphenatedProp = {
	transform: "transform",
	msTransform: "-ms-transform",
	MozTransform: "-moz-transform",
	webkitTransform: "-webkit-transform",
	OTransform: "-o-transform",
}[prop];
var percentagesAndLengths = [
	".0",
	"-53.7px", "-1px", "0.0px", "0.12px", "1px", "53.7px",
	"-50%", "0%", "0.12%",
	"1em", "1ex", "1in", "1cm", "1mm", "1pt", "1pc"];
var emPixels = parseFloat(getComputedStyle(div).fontSize);
div.style.fontSize = "1ex";
var exPixels = parseFloat(getComputedStyle(div).fontSize);
div.removeAttribute("style");

var switchStyles = document.querySelectorAll("style.switch");
[].forEach.call(switchStyles, function(style) { style.disabled = true });

/**
 * Accepts a string that's a CSS length or percentage, and returns a number of
 * pixels (not a string), or null if parsing fails.  For percentages to be
 * accepted, percentRef must not be undefined.
 */
function convertToPx(input, percentRef) {
	var match = /^([-+]?[0-9]+|[-+]?[0-9]*\.[0-9]+)(em|ex|in|cm|mm|pt|pc|px|%)?$/.exec(input);
	if (!match) {
		return null;
	}
	var amount = Number(match[1]);
	var unit = match[2];
	if (amount == 0) {
		return 0;
	}
	if (!unit) {
		return null;
	}
	if (unit == "%" && percentRef === undefined) {
		return null;
	}
	return amount * {
		em: emPixels,
		ex: exPixels,
		in: 72/0.75,
		cm: (1/2.54)*72/0.75,
		mm: (1/25.4)*72/0.75,
		pt: 1/0.75,
		pc: 12/0.75,
		px: 1,
		"%": percentRef/100,
	}[unit];
}

/**
 * Accepts a string that's a CSS angle, and returns a number of radians (not a
 * string), or null if parsing fails.
 */
function convertToRad(input) {
	var match = /^([-+]?[0-9]+|[-+]?[0-9]*\.[0-9]+)(deg|grad|rad|turn)$/.exec(input);
	if (!match) {
		return null;
	}
	var amount = Number(match[1]);
	var unit = match[2];
	return amount * {
		deg: Math.PI/180,
		grad: Math.PI/200,
		rad: 1,
		turn: 2*Math.PI,
	}[unit];
}

/**
 * Multiplies two 3x2 matrices.
 */
function mxmul(A, B) {
	return [
		A[0]*B[0] + A[2]*B[1],
		A[1]*B[0] + A[3]*B[1],
		A[0]*B[2] + A[2]*B[3],
		A[1]*B[2] + A[3]*B[3],
		A[0]*B[4] + A[2]*B[5] + A[4],
		A[1]*B[4] + A[3]*B[5] + A[5]
	];
}

/**
 * Tests that style="transform: value" results in transformation by the matrix
 * [a, b, c, d, e, f].  Checks both the computed value and bounding box.
 */
function testTransform(value, a, b, c, d, e, f) {
	div.removeAttribute("style");
	// FIXME: The spec doesn't match browsers for serialization of the
	// transform property when it's unset or "none".
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15471
	if (value != "none") {
		test(function() {
			div.style[prop] = value;
			testTransformParsing(a, b, c, d, e, f);
		}, "Computed value for transform: " + value + " set via CSSOM");
		test(function() {
			div.setAttribute("style", hyphenatedProp + ": " + value);
			testTransformParsing(a, b, c, d, e, f);
		}, "Computed value for transform: " + value + " set via setAttribute()");
	}
	testTransformedBoundary(value, a, b, c, d, e, f, "50% 50%", divWidth/2, divHeight/2);
}

/**
 * Tests that div's computed style for transform is "matrix(a, b, c, d, e, f)".
 */
function testTransformParsing(a, b, c, d, e, f) {
	// FIXME: We allow px optionally in the last two entries because Gecko
	// adds it while other engines don't, and the spec is unclear about
	// which behavior is correct:
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15431
	var computed = getComputedStyle(div)[prop];
	var re = /^matrix\(([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+?)(?:px)?, ([^,]+?)(?:px)?\)$/;
	assert_regexp_match(computed, re, "computed value has unexpected form");
	var match = re.exec(computed);
	assert_approx_equals(Number(match[1]), a, epsilon, "getComputedStyle first matrix component");
	assert_approx_equals(Number(match[2]), b, epsilon, "getComputedStyle second matrix component");
	assert_approx_equals(Number(match[3]), c, epsilon, "getComputedStyle third matrix component");
	assert_approx_equals(Number(match[4]), d, epsilon, "getComputedStyle fourth matrix component");
	assert_approx_equals(Number(match[5]), e, epsilon, "getComputedStyle fifth matrix component");
	assert_approx_equals(Number(match[6]), f, epsilon, "getComputedStyle sixth matrix component");
}

/**
 * Tests that
 *   style="transform: transformValue; transform-origin: transformOriginValue"
 * results in the boundary box that you'd get from transforming with a matrix
 * of [a, b, c, d, e, f] around an offset of [xOffset, yOffset].
 */
function testTransformedBoundary(transformValue, a, b, c, d, e, f,
                                 transformOriginValue, xOffset, yOffset) {
	var originalPoints = [[0, 0], [0, divHeight], [divWidth, 0], [divWidth, divHeight]];
	var expectedTop, expectedRight, expectedBottom, expectedLeft;
	for (var i = 0; i < originalPoints.length; i++) {
		var newX = a*(originalPoints[i][0]-xOffset) + c*(originalPoints[i][1]-yOffset) + e + xOffset;
		var newY = b*(originalPoints[i][0]-xOffset) + d*(originalPoints[i][1]-yOffset) + f + yOffset;
		if (expectedTop === undefined || newY < expectedTop) {
			expectedTop = newY;
		}
		if (expectedRight === undefined || newX > expectedRight) {
			expectedRight = newX;
		}
		if (expectedBottom === undefined || newY > expectedBottom) {
			expectedBottom = newY;
		}
		if (expectedLeft === undefined || newX < expectedLeft) {
			expectedLeft = newX;
		}
	}
	// Don't test singular matrices for now.  IE fails some of them, which
	// might be due to getBoundingClientRect() instead of transforms.
	if (a*d - b*c === 0) {
		return;
	}

	// Pick a different <style class=switch> for each test; they shouldn't
	// affect results
	if (testTransformedBoundary.switchStyleIdx === undefined) {
		testTransformedBoundary.switchStyleIdx = switchStyles.length - 1;
	}
	switchStyles[testTransformedBoundary.switchStyleIdx].disabled = true;
	testTransformedBoundary.switchStyleIdx++;
	testTransformedBoundary.switchStyleIdx %= switchStyles.length;
	switchStyles[testTransformedBoundary.switchStyleIdx].disabled = false;

	div.removeAttribute("style");
	test(function() {
		div.style[prop] = transformValue;
		div.style[prop + "Origin"] = transformOriginValue;
		testTransformedBoundaryAsserts(expectedTop, expectedRight, expectedBottom, expectedLeft);
	}, "Boundaries with transform: " + transformValue + "; transform-origin: " + transformOriginValue + " set via CSSOM; switch style " + testTransformedBoundary.switchStyleIdx);
	test(function() {
		div.setAttribute("style", hyphenatedProp + ": " + transformValue + "; "
			+ hyphenatedProp + "-origin: " + transformOriginValue);
		testTransformedBoundaryAsserts(expectedTop, expectedRight, expectedBottom, expectedLeft);
	}, "Boundaries with transform: " + transformValue + "; transform-origin: " + transformOriginValue + " set via setAttribute(); switch style " + testTransformedBoundary.switchStyleIdx);
}

function testTransformedBoundaryAsserts(expectedTop, expectedRight, expectedBottom, expectedLeft) {
	// FIXME: We assume getBoundingClientRect() returns the rectangle
	// that contains the transformed box, not the untransformed box.
	// This is not actually specified anywhere:
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15430
	var rect = div.getBoundingClientRect();
	assert_approx_equals(rect.top, expectedTop, epsilon, "top");
	assert_approx_equals(rect.right, expectedRight, epsilon, "right");
	assert_approx_equals(rect.bottom, expectedBottom, epsilon, "bottom");
	assert_approx_equals(rect.left, expectedLeft, epsilon, "left");
	assert_approx_equals(rect.width, expectedRight - expectedLeft, epsilon, "width");
	assert_approx_equals(rect.height, expectedBottom - expectedTop, epsilon, "height");
}

// Test case-sensitivity
[
	// FIXME: The spec doesn't match browsers for serialization of the
	// transform property when it's unset or "none".
	// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15471
	// [["none", "NONE", "nOnE"], 1, 0, 0, 1, 0, 0],
	[["matrix(1,2,3,4,5,6)", "MATRIX(1,2,3,4,5,6)", "mAtRiX(1,2,3,4,5,6)"], 1, 2, 3, 4, 5, 6],
	[["translate(1px)", "TRANSLATE(1PX)", "tRaNsLaTe(1Px)"], 1, 0, 0, 1, 1, 0],
	[["translatex(1pt)", "TRANSLATEX(1PT)", "tRaNsLaTeX(1pT)"], 1, 0, 0, 1, 0.75, 0],
	[["translatey(1in)", "TRANSLATEY(1IN)", "tRaNsLaTeY(1iN)"], 1, 0, 0, 1, 0, 96],
	[["scale(2)", "SCALE(2)", "sCaLe(2)"], 2, 0, 0, 2, 0, 0],
	[["scalex(2)", "SCALEX(2)", "sCaLeX(2)"], 2, 0, 0, 1, 0, 0],
	[["scaley(2)", "SCALEY(2)", "sCaLeY(2)"], 1, 0, 0, 2, 0, 0],
	// Nothing much uses angle units, so I'll test the case-insensitivity of
	// those while I'm here.
	[["rotate(90deg)", "ROTATE(90DEG)", "rOtAtE(90dEg)",
	  "rotate(100grad)", "ROTATE(100GRAD)", "rOtAtE(100gRaD)",
	  "rotate(0.7854rad)", "ROTATE(0.7854RAD)", "rOtAtE(0.7854rAd)",
	  "rotate(0.25turn)", "ROTATE(0.25TUN)", "rOtAtE(0.25tUrN)"], 0, 1, -1, 0, 0, 0],
	[["skewx(45deg)", "SKEWX(45DEG)", "sKeWx(45DeG)"], 1, 0, 1, 1, 0, 0],
	[["skewy(45deg)", "SKEWY(45DEG)", "sKeWy(45DeG)"], 1, 1, 0, 1, 0, 0],
].forEach(function(arr) {
	arr[0].forEach(function(transform, i) {
		var transformKeyword = {0: "TRANSFORM", 1: "tRAnSFoRM", 2: "transform"}[i%3];
		test(function() {
			div.style[prop.replace("transform", transformKeyword)] = transform;
			testTransformParsing(arr[1], arr[2], arr[3], arr[4], arr[5], arr[6]);
		}, "Computed value for " + transformKeyword + ": " + transform + " set via CSSOM");
	});
});
div.removeAttribute("style");

// FIXME: The spec doesn't match browsers for serialization of the transform
// property when it's unset or "none".
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15471
//test(function() {
//	testTransformParsing(1, 0, 0, 1, 0, 0);
//}, "Computed value for transform with no style attribute");
test(function() {
	// Not really a transform test, just included for completeness.  It can
	// serve as something of a sanity check.
	testTransformedBoundaryAsserts(0, divWidth, divHeight, 0);
}, "Boundaries with no style attribute");

testTransform("none", 1, 0, 0, 1, 0, 0);

// Test style="transform: matrix(*)" (4^6 = 4096 permutations, but we only run
// every 13th to avoid creating excessive numbers of tests)
(function(){
var matrixValues = [-1, 0, 1, 1.72];
var i = 0;
matrixValues.forEach(function(a) {
matrixValues.forEach(function(b) {
matrixValues.forEach(function(c) {
matrixValues.forEach(function(d) {
matrixValues.forEach(function(e) {
matrixValues.forEach(function(f) {
	if (i % 13 == 0) {
		testTransform(
			"matrix(" + a + ", " + b + ", " + c + ", " + d + ", " + e + ", " + f + ")",
			a, b, c, d, e, f
		);
	}
	i++;
	i %= 13;
});
});
});
});
});
});
})();

// Test translate()/translateX()/translateY()
percentagesAndLengths.forEach(function(tx) {
	testTransform(
		"translateX(" + tx + ")",
		1, 0, 0, 1, convertToPx(tx, divWidth), 0
	);
	// tx is poorly named, since it's used for y here.
	testTransform(
		"translateY(" + tx + ")",
		1, 0, 0, 1, 0, convertToPx(tx, divHeight)
	);
	testTransform(
		"translate(" + tx + ")",
		1, 0, 0, 1, convertToPx(tx, divWidth), 0
	);

	percentagesAndLengths.forEach(function(ty) {
		testTransform(
			"translate(" + tx + ", " + ty + ")",
			1, 0, 0, 1, convertToPx(tx, divWidth), convertToPx(ty, divHeight)
		);
	});
});

// Test scale()/scaleX()/scaleY()
(function(){
var scales = [-2, -1, -0.12, 0, 0.12, 1, 2];
scales.forEach(function(sx) {
	testTransform(
		"scaleX(" + sx + ")",
		sx, 0, 0, 1, 0, 0
	);
	// sx is poorly named, since it's used for y here, then for both x and y.
	testTransform(
		"scaleY(" + sx + ")",
		1, 0, 0, sx, 0, 0
	);
	testTransform(
		"scale(" + sx + ")",
		sx, 0, 0, sx, 0, 0
	);

	scales.forEach(function(sy) {
		testTransform(
			"scale(" + sx + ", " + sy + ")",
			sx, 0, 0, sy, 0, 0
		);
	});
});
})();

// Test rotate()
[
	"-7deg", "0deg", "22.5deg", "45deg", "86.451deg", "90deg", "180deg",
	"270deg", "452deg",
	"-1rad", "0rad", "1rad", "6.28rad",
	"0.721turn", "256grad",
].forEach(function(angle) {
	var rads = convertToRad(angle);
	testTransform(
		"rotate(" + angle + ")",
		Math.cos(rads), Math.sin(rads), -Math.sin(rads), Math.cos(rads),
		0, 0
	);
});

// Test skewX()/skewY()
//
// Do not test values close to 90 degrees, because this will cause coordinates
// to get large.  The maximum values for coordinates are (of course) not
// defined, and even if they were, the result would be extremely sensitive to
// rounding error.
[
	"-80deg", "-45deg", "-32.6deg", "-0.05deg", "0deg", "0.05deg", "32.6deg",
	"45deg", "80deg", "300deg",
	"-0.3rad", "0rad", "0.3rad", "2.9rad",
	"0.921turn", "22grad"
].forEach(function(angle) {
	testTransform(
		"skewX(" + angle + ")",
		1, 0, Math.tan(convertToRad(angle)), 1, 0, 0
	);
	testTransform(
		"skewY(" + angle + ")",
		1, Math.tan(convertToRad(angle)), 0, 1, 0, 0
	);
});

// Test multiple transformations
(function(){
var transforms = [
	["matrix(4, -7, 2.3, -3.8, 6, 6)", 4, -7, 2.3, -3.8, 6, 6],
	["translate(22.1%, -17pt)",
		1, 0, 0, 1, convertToPx("22.1%", divWidth), convertToPx("-17pt")],
	["scale(1.3, -5.6)", 1.3, 0, 0, -5.6, 0, 0],
	["rotate(0.759rad)", Math.cos(0.759), Math.sin(0.759),
		-Math.sin(0.759), Math.cos(0.759), 0, 0],
	["skewX(-0.221rad)", 1, 0, Math.tan(-0.221), 1, 0, 0],
];
transforms.forEach(function(trans1) {
	testTransform(trans1[0], trans1[1], trans1[2],
		trans1[3], trans1[4], trans1[5], trans1[6]);

	transforms.forEach(function(trans2) {
		var mx = mxmul(trans1.slice(1), trans2.slice(1));
		testTransform(trans1[0] + " " + trans2[0],
			mx[0], mx[1], mx[2], mx[3], mx[4], mx[5]);

		transforms.forEach(function(trans3) {
			var mx = mxmul(mxmul(trans1.slice(1), trans2.slice(1)), trans3.slice(1));
			testTransform(trans1[0] + " " + trans2[0] + " " + trans3[0],
				mx[0], mx[1], mx[2], mx[3], mx[4], mx[5]);
		});
	});
});
})();


/**
 * Test that "transform-origin: value" acts like the origin is at
 * (expectedHoriz, expectedVert), where the latter two parameters can be
 * keywords, percentages, or lengths.  Tests both that the computed value is
 * correct, and that the boundary box is as expected for a 45-degree rotation.
 */
function testTransformOrigin(value, expectedHoriz, expectedVert) {
	if (expectedHoriz == "left") {
		expectedHoriz = "0%";
	} else if (expectedHoriz == "center") {
		expectedHoriz = "50%";
	} else if (expectedHoriz == "right") {
		expectedHoriz = "100%";
	}
	if (expectedVert == "top") {
		expectedVert = "0%";
	} else if (expectedVert == "center") {
		expectedVert = "50%";
	} else if (expectedVert == "bottom") {
		expectedVert = "100%";
	}
	// FIXME: Nothing defines resolved values here.  I picked the behavior of
	// all non-Gecko engines, which is also the behavior Gecko for transforms
	// other than "none": https://www.w3.org/Bugs/Public/show_bug.cgi?id=15433
	expectedHoriz = convertToPx(expectedHoriz, divWidth);
	expectedVert = convertToPx(expectedVert, divHeight);

	if (testTransformOrigin.counter === undefined) {
		testTransformOrigin.counter = 0;
	}
	// The transform doesn't matter here, so set it to one of several
	// possibilities arbitrarily (this actually catches a Gecko bug!)
	var transformValue = {
		0: "none",
		1: "matrix(7, 0, -1, 13, 0, 0)",
		2: "translate(4em, -15px)",
		3: "scale(1.2, 1)",
		4: "rotate(43deg)",
	}[testTransformOrigin.counter % 5];
	testTransformOrigin.counter++;
	div.removeAttribute("style");

	test(function() {
		div.style[prop] = transformValue;
		div.style[prop + "Origin"] = value;
		testTransformOriginParsing(expectedHoriz, expectedVert);
	}, "Computed value for transform-origin with transform: " + transformValue + "; transform-origin: " + value + " set via CSSOM");
	test(function() {
		div.setAttribute("style", hyphenatedProp + ": " + transformValue
			+ "; " + hyphenatedProp + "-origin:" + value);
		testTransformOriginParsing(expectedHoriz, expectedVert);
	}, "Computed value for transform-origin with transform: " + transformValue + "; transform-origin: " + value + " set via setAttribute()");

	// Test with a 45-degree rotation, since the effect of changing the origin
	// will be easy to understand.
	testTransformedBoundary(
		// Transform
		"rotate(45deg)",
		// Matrix entries
		Math.cos(Math.PI/4), Math.sin(Math.PI/4),
		-Math.sin(Math.PI/4), Math.cos(Math.PI/4),
		0, 0,
		// Origin
		value, expectedHoriz, expectedVert
	);
}

/**
 * Tests that style="transform-origin: value" results in
 * getComputedStyle().transformOrigin being expectedHoriz + "px " + expectedVert + "px".
 */
function testTransformOriginParsing(expectedHoriz, expectedVert) {
	var actual = getComputedStyle(div)[prop + "Origin"];
	var re = /^([^ ]+)px ([^ ]+)px$/;
	assert_regexp_match(actual, re, "Computed value has unexpected form");
	var match = re.exec(actual);

	assert_approx_equals(Number(match[1]), expectedHoriz,
		epsilon, "Value of horizontal part (actual: "
			 + actual + ", expected " + expectedHoriz + "px " + expectedVert + "px)");

	assert_approx_equals(Number(match[2]), expectedVert,
		epsilon, "Value of vertical part (actual: "
			 + actual + ", expected " + expectedHoriz + "px " + expectedVert + "px)");
}

// Test transform-origin with one argument
[
	["none", "50%", "50%"],
	["NONE", "50%", "50%"],
	["nOnE", "50%", "50%"],
	["quasit", "50%", "50%"],
	["top", "50%", "0%"],
	["TOP", "50%", "0%"],
	["tOp", "50%", "0%"],
	["right", "100%", "50%"],
	["RIGHT", "100%", "50%"],
	["rIgHt", "100%", "50%"],
	["bottom", "50%", "100%"],
	["BOTTOM", "50%", "100%"],
	["bOtToM", "50%", "100%"],
	["left", "0%", "50%"],
	["LEFT", "0%", "50%"],
	["lEfT", "0%", "50%"],
	["center", "50%", "50%"],
	["CENTER", "50%", "50%"],
	["cEnTeR", "50%", "50%"],
	["37%", "37%", "50%"],
	["117%", "117%", "50%"],
	["41.2px", "41.2px", "50%"],
	["-31.8px", "-31.8px", "50%"],
].forEach(function(arr) {
	testTransformOrigin(arr[0], arr[1], arr[2]);
});

// Test transform-origin with two arguments.
["left", "center", "right"].concat(percentagesAndLengths).forEach(function(arg1) {
	["top", "center", "bottom"].concat(percentagesAndLengths).forEach(function(arg2) {
		testTransformOrigin(arg1 + " " + arg2, arg1, arg2);
	});
});

// FIXME: Three- and four-value variants are not generally implemented
// https://www.w3.org/Bugs/Public/show_bug.cgi?id=15432
/*
percentagesAndLengths.forEach(function(height) {
	// height is a misnomer, it's also used for width in this part.
	// Three arguments with width first:
	testTransformOrigin("center top " + height, "", "");
	testTransformOrigin("center bottom " + height, "", "");

	testTransformOrigin("left " + height + " center", "", "");
	testTransformOrigin("left " + height + " top", "", "");
	testTransformOrigin("left " + height + " bottom", "", "");
	testTransformOrigin("left top " + height, "", "");
	testTransformOrigin("left bottom " + height, "", "");

	testTransformOrigin("right " + height + " center", "", "");
	testTransformOrigin("right " + height + " top", "", "");
	testTransformOrigin("right " + height + " bottom", "", "");
	testTransformOrigin("right top " + height, "", "");
	testTransformOrigin("right bottom " + height, "", "");

	// Three arguments with height first:
	testTransformOrigin("center left " + height, "", "");
	testTransformOrigin("center right " + height, "", "");

	testTransformOrigin("top " + height + " center", "", "");
	testTransformOrigin("top " + height + " left", "", "");
	testTransformOrigin("top " + height + " right", "", "");
	testTransformOrigin("top left " + height, "", "");
	testTransformOrigin("top right " + height, "", "");

	testTransformOrigin("bottom " + height + " center", "", "");
	testTransformOrigin("bottom " + height + " left", "", "");
	testTransformOrigin("bottom " + height + " right", "", "");
	testTransformOrigin("bottom left " + height, "", "");
	testTransformOrigin("bottom right " + height, "", "");

	// Four arguments
	percentagesAndLengths.forEach(function(width) {
		// Width first:
		testTransformOrigin("left " + width + " top " + height, "", "");
		testTransformOrigin("left " + width + " bottom " + height, "", "");
		testTransformOrigin("right " + width + " top " + height, "", "");
		testTransformOrigin("right " + width + " bottom " + height, "", "");

		// Height first:
		testTransformOrigin("top " + height + " left " + width, "", "");
		testTransformOrigin("top " + height + " right " + width, "", "");
		testTransformOrigin("bottom " + height + " left " + width, "", "");
		testTransformOrigin("bottom " + height + " right " + width, "", "");
	});
});
*/

[].forEach.call(document.querySelectorAll("style"), function(style) {style.disabled = true});
</script>
