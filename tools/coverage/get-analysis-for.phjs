/*global phantom*/

var page = require("webpage").create()
,   system = require("system")
,   url
;

if (system.args.length === 1) {
    console.log("[ERROR] URL argument required.");
    phantom.exit();
}
else {
    url = system.args[1];
}

page.open(url, function (status) {
    if (status !== "success") {
        console.log("[ERROR] Failed to load page");
        phantom.exit();
    }
    
    page.includeJs("https://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js", function () {
        var toc = page.evaluate(function () {
            var tocList = [];
            function walkToC ($, $el, list, level) {
                level++;
                $el.find("> li").each(function () {
                    var $li = $(this)
                    ,   $a = $li.find("> a").first()
                    ;
                    var href = $a.attr("href").replace(/^.*#/, "")
                    ,   def = {
                            id: href.toLowerCase()
                                    .replace(/[^a-z0-9\-]/g, "-")
                                    .replace(/\-{2,}/g, "-")
                                    .replace(/(?:^\-|\-$)/g, "")
                        ,   original_id: href
                        ,   level:  level
                        }
                    ,   $ol = $li.find("> ol").first()
                    ;
                    list.push(def);
                    if ($ol.length && level < 3) {
                        walkToC($, $ol, list, level);
                    }
                });
            }
            
            function processTocForRanges (tocList) {
                for (var i = 0, n = tocList.length; i < n; i++) {
                    var section = tocList[i]
                    ,   level = section.level
                    ;
                    section.end_id = null;
                    for (var j = i + 1, m = tocList.length; j < m; j++) {
                        var next = tocList[j];
                        if (next.level === level || next.level < level) {
                            section.end_id = next.original_id;
                            break;
                        }
                    }
                }
            }
            
            function getNodesForSection (section) {
                var xpath, nodes = [];
                // let me get all Kayessian on your arse!
                if (section.end_id) {
                    xpath = "id('" + section.original_id + "')/following-sibling::node()[count(.| id('" + section.end_id + "')/preceding-sibling::node())=count(id('" + section.end_id + "')/preceding-sibling::node())]";
                }
                else {
                    xpath = "id('" + section.original_id + "')/following-sibling::node()";
                }
                var xpr = document.evaluate(xpath, document.documentElement, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                for (var j = 0, m = xpr.snapshotLength; j < m; j++) nodes.push(xpr.snapshotItem(j));
                return nodes;
            }

            function getFragmentForSection (section) {
                var nodes = getNodesForSection(section)
                ,   df = document.createDocumentFragment()
                ;
                for (var j = 0, m = nodes.length; j < m; j++) df.appendChild(nodes[j].cloneNode(true));
                return df;
            }

            // process ToC
            var $toc = $("body > ol.toc").first()
            ;
            walkToC($, $toc, tocList, 0);
            processTocForRanges(tocList);
            
            // remove non-normative sections from the document
            $("p:contains('This section is non-normative.')").prev().each(function () {
                var id = $(this).attr("id");
                for (var i = 0, n = tocList.length; i < n; i++) {
                    if (tocList[i].id === id) {
                        var nodes = getNodesForSection(tocList[i]);
                        for (var j = 0, m = nodes.length; j < m; j++) $(nodes[j]).remove();
                        tocList.splice(i, 1);
                        break;
                    }
                }
            });
            
            // we now need to recompute the ranges
            processTocForRanges(tocList);

            // turn ranges to DFs
            for (var i = 0, n = tocList.length; i < n; i++) {
                var section = tocList[i]
                ,   $df = $(getFragmentForSection(section));
                // ranges[tocList[i].id] = $df;
                // remove non-normative content inside DFs
                $df.find(".example, .domintro").remove();

                // count webidl complexity (then remove webidls)
                section.idlComplexity = $df.find(".idl:not(.extract)")
                                           .text()
                                           .replace(/\/\/.*$/gm, "")
                                           .replace(/^\s*$/gm, "")
                                           .replace(/^\s*\}\s*;\s*$/gm, "")
                                           .split("\n")
                                           .length;
                $df.find(".idl").remove();

                // count words
                section.wordCount = $df.text().split(/\s+/).length;

                // count "ol li"
                section.algorithmicSteps = $df.find("ol li").length;
                
                // count normative statements
                var norms = $df.text().match(/\b(should|must)\b/g);
                section.normativeStatements = norms ? norms.length : 0;
            }
            return tocList;
        });
        console.log(JSON.stringify(toc));
        phantom.exit();
    });
    
});


// var nodes = []
// ,   doc = window.document
// ,   start = doc.getElementById(section.original_id)
// ;
// console.log(start);
// if (section.end_id) {
//     var end = doc.getElementById(section.end_id);
//     var nxt = start;
//     console.log("Start '%s' (%s) and end at '%s' (%s)", start.innerHTML, section.original_id, end.innerHTML, section.end_id);
//     while (nxt = start.nextSibling) {
//         // compareDocumentPosition -- because bitmasks are just so cool
//         if (nxt.compareDocumentPosition(end) & nxt.DOCUMENT_POSITION_FOLLOWING) {
//             // console.log("Adding node...");
//             nodes.push(nxt);
//         }
//         else {
//             break;
//         }
//     }
// }
// else {
//     console.log("Start '%s' and end at EOF", $(start).text());
//     var nxt = start;
//     while (nxt = start.nextSibling) nodes.push(nxt);
// }
// ranges[spec][section.id] = $(nodes);
// console.log("OK with %d", nodes.length);
// // console.log(nodes);
